{
  "language": "Solidity",
  "sources": {
    "contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\nimport {sub} from \"../../vendor/DSMath.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    IConnectInstaPoolV2\n} from \"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\nimport {\n    IBInstaFeeCollector\n} from \"../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\nimport {DAI} from \"../../constants/CTokens.sol\";\nimport {\n    CONNECT_MAKER,\n    CONNECT_AAVE_V2,\n    CONNECT_BASIC,\n    INSTA_POOL_V2\n} from \"../../constants/CInstaDapp.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../functions/dapps/FMaker.sol\";\nimport {\n    _encodeFlashPayback\n} from \"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\";\nimport {\n    _encodePaybackMakerVault,\n    _encodedWithdrawMakerVault\n} from \"../../functions/InstaDapp/connectors/FConnectMaker.sol\";\nimport {\n    _encodeDepositAave,\n    _encodeBorrowAave\n} from \"../../functions/InstaDapp/connectors/FConnectAave.sol\";\nimport {\n    _encodeCalculateFee\n} from \"../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\";\nimport {_getGelatoExecutorFees} from \"../../functions/gelato/FGelato.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToAave,\n    _getRealisedDebt\n} from \"../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {IOracleAggregator} from \"../../interfaces/gelato/IOracleAggregator.sol\";\nimport {\n    BInstaFeeCollector\n} from \"../../contracts/connectors/base/BInstaFeeCollector.sol\";\nimport {\n    _encodeBasicWithdraw\n} from \"../../functions/InstaDapp/connectors/FConnectBasic.sol\";\n\ncontract MockConnectGelatoDataMakerToAave is\n    ConnectorInterface,\n    BInstaFeeCollector\n{\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable const-name-snakecase\n    string public constant override name =\n        \"MockConnectGelatoDataMakerToAave-v1.0\";\n    uint256 internal immutable _id;\n    address internal immutable _oracleAggregator;\n    address public immutable connectGelatoDataMakerToAaveAddr;\n\n    constructor(\n        uint256 __id,\n        address __oracleAggregator,\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    )\n        BInstaFeeCollector(\n            _fee,\n            _feeCollector,\n            _minDebt,\n            __connectGelatoDebtBridgeFee\n        )\n    {\n        _id = __id;\n        _oracleAggregator = __oracleAggregator;\n        connectGelatoDataMakerToAaveAddr = address(this);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    // Overriding IGelatoAction's function (optional)\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow,\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        (, uint256 vaultId, ) =\n            abi.decode(_actionData[4:], (uint256, uint256, address));\n\n        if (vaultId == 0)\n            return \"ConnectGelatoDataMakerToAave: Vault Id is not valid\";\n        if (!_isVaultOwner(vaultId, _dsa))\n            return \"ConnectGelatoDataMakerToAave: Vault not owned by dsa\";\n        if (_getMakerVaultCollateralBalance(vaultId) < minDebt)\n            return \"ConnectGelatoDataMakerToAave: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _mockRoute mock route Id.\n    /// @param _vaultId Id of the unsafe vault of the client of Vault A Collateral.\n    /// @param _colToken  vault's col token address .\n    function getDataAndCastMakerToAave(\n        uint256 _mockRoute,\n        uint256 _vaultId,\n        address _colToken\n    ) external payable {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataMakerToAave(_mockRoute, _vaultId, _colToken);\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n        if (!success) {\n            returndata.revertWithError(\"ConnectGelatoDataMakerToAave._cast:\");\n        }\n    }\n\n    /* solhint-disable function-max-lines */\n\n    function _dataMakerToAave(\n        uint256 _mockRoute,\n        uint256 _vaultId,\n        address _colToken\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](1);\n        targets[0] = INSTA_POOL_V2;\n\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\n\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\n        route = _mockRoute;\n        (uint256 gasFeesPaidFromBor, ) =\n            IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n                _getGelatoExecutorFees(_getGasCostMakerToAave(route)),\n                DAI,\n                _colToken\n            );\n\n        (address[] memory _targets, bytes[] memory _datas) =\n            _spellsMakerToAave(\n                _vaultId,\n                _colToken,\n                daiToBorrow,\n                _getMakerVaultCollateralBalance(_vaultId),\n                gasFeesPaidFromBor\n            );\n\n        datas = new bytes[](1);\n        datas[0] = abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n            DAI,\n            daiToBorrow,\n            route,\n            abi.encode(_targets, _datas)\n        );\n    }\n\n    function _spellsMakerToAave(\n        uint256 _vaultId,\n        address _colToken,\n        uint256 _daiDebtAmt,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](8);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_AAVE_V2; // deposit\n        targets[4] = CONNECT_AAVE_V2; // borrow\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n        targets[7] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](8);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToAaveAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodeDepositAave(_colToken, _colToWithdrawFromMaker, 0, 0);\n        datas[4] = _encodeBorrowAave(DAI, 0, 2, 600, 0); // Variable rate by default.\n        datas[5] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToAaveAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n    }\n\n    /* solhint-enable function-max-lines */\n}\n"
    },
    "contracts/lib/GelatoBytes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nlibrary GelatoBytes {\n    function calldataSliceSelector(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function memorySliceSelector(bytes memory _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly {\n                selector := mload(add(0x20, _bytes))\n            }\n            if (selector == 0x08c379a0) {\n                // Function selector for Error(string)\n                assembly {\n                    _bytes := add(_bytes, 68)\n                }\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n            } else {\n                revert(\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"))\n                );\n            }\n        } else {\n            revert(\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"))\n            );\n        }\n    }\n\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n        returns (string memory)\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly {\n                selector := mload(add(0x20, _bytes))\n            }\n            if (selector == 0x08c379a0) {\n                // Function selector for Error(string)\n                assembly {\n                    _bytes := add(_bytes, 68)\n                }\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\n            } else {\n                return\n                    string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\"));\n            }\n        } else {\n            return\n                string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\"));\n        }\n    }\n}\n"
    },
    "contracts/vendor/DSMath.sol": {
      "content": "// \"SPDX-License-Identifier: AGPL-3.0-or-later\"\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.0;\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    require((z = x + y) >= x, \"ds-math-add-overflow\");\n}\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n}\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    return x <= y ? x : y;\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    return x >= y ? x : y;\n}\n\nfunction imin(int256 x, int256 y) pure returns (int256 z) {\n    return x <= y ? x : y;\n}\n\nfunction imax(int256 x, int256 y) pure returns (int256 z) {\n    return x >= y ? x : y;\n}\n\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**27;\n\n//rounds to zero if x*y < WAD / 2\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, y), WAD / 2) / WAD;\n}\n\n//rounds to zero if x*y < WAD / 2\nfunction rmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, y), RAY / 2) / RAY;\n}\n\n//rounds to zero if x*y < WAD / 2\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, WAD), y / 2) / y;\n}\n\n//rounds to zero if x*y < RAY / 2\nfunction rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, RAY), y / 2) / y;\n}\n\n// This famous algorithm is called \"exponentiation by squaring\"\n// and calculates x^n with x as fixed-point and n as regular unsigned.\n//\n// It's O(log n), instead of O(n) for naive repeated multiplication.\n//\n// These facts are why it works:\n//\n//  If n is even, then x^n = (x^2)^(n/2).\n//  If n is odd,  then x^n = x * x^(n-1),\n//   and applying the equation for even x gives\n//    x^n = x * (x^2)^((n-1) / 2).\n//\n//  Also, EVM division is flooring and\n//    floor[(n-1) / 2] = floor[n / 2].\n//\nfunction rpow(uint256 x, uint256 n) pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n        x = rmul(x, x);\n\n        if (n % 2 != 0) {\n            z = rmul(z, x);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/InstaDapp/IInstaDapp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n/// @notice Interface InstaDapp Index\ninterface IndexInterface {\n    function connectors(uint256 version) external view returns (address);\n\n    function list() external view returns (address);\n}\n\n/// @notice Interface InstaDapp List\ninterface ListInterface {\n    function accountID(address _account) external view returns (uint64);\n}\n\n/// @notice Interface InstaDapp InstaMemory\ninterface MemoryInterface {\n    function setUint(uint256 _id, uint256 _val) external;\n\n    function getUint(uint256 _id) external returns (uint256);\n}\n\n/// @notice Interface InstaDapp Defi Smart Account wallet\ninterface AccountInterface {\n    function cast(\n        address[] calldata _targets,\n        bytes[] calldata _datas,\n        address _origin\n    ) external payable returns (bytes32[] memory responses);\n\n    function version() external view returns (uint256);\n\n    function isAuth(address user) external view returns (bool);\n\n    function shield() external view returns (bool);\n}\n\ninterface ConnectorInterface {\n    function connectorID() external view returns (uint256 _type, uint256 _id);\n\n    function name() external view returns (string memory);\n}\n\ninterface InstaMapping {\n    function gemJoinMapping(bytes32) external view returns (address);\n\n    function cTokenMapping(address) external view returns (address);\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectInstaPoolV2 {\n    function flashBorrowAndCast(\n        address token,\n        uint256 amt,\n        uint256 route,\n        bytes memory data\n    ) external payable;\n\n    function flashPayback(\n        address token,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IBInstaFeeCollector {\n    function setFeeCollector(address payable _feeCollector) external;\n\n    function setMinDebt(uint256 _minDebt) external;\n\n    function fee() external view returns (uint256);\n\n    function feeCollector() external view returns (address payable);\n\n    function minDebt() external view returns (uint256);\n}\n"
    },
    "contracts/constants/CTokens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// ETH\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n// USD\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n"
    },
    "contracts/constants/CInstaDapp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// InstaDapp\naddress constant INSTA_MEMORY = 0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F;\n\n// Connectors\naddress constant CONNECT_MAKER = 0xac02030d8a8F49eD04b2f52C394D3F901A10F8A9;\naddress constant CONNECT_COMPOUND = 0x15FdD1e902cAC70786fe7D31013B1a806764B5a2;\naddress constant INSTA_POOL_V2 = 0xeB4bf86589f808f90EEC8e964dBF16Bd4D284905;\naddress constant CONNECT_AAVE_V2 = 0xBF6E4331ffd02F7043e62788FD272aeFc712f5ee;\naddress constant CONNECT_DYDX = 0x6AF6C791c869DfA65f8A2fa042fA47D1535Bef25;\naddress constant CONNECT_BASIC = 0xe5398f279175962E56fE4c5E0b62dc7208EF36c6;\naddress constant CONNECT_FEE = 0xB99152F8073033B318C1Bfbfaaa582029e982CE9;\n\n// Insta Pool\naddress constant INSTA_POOL_RESOLVER = 0xa004a5afBa04b74037E9E52bA1f7eb02b5E61509;\nuint256 constant ROUTE_1_TOLERANCE = 1005e15;\n\n// Insta Mapping\naddress constant INSTA_MAPPING = 0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88;\n\naddress constant INSTA_MAKER_RESOLVER = 0x0A7008B38E7015F8C36A49eEbc32513ECA8801E5;\n"
    },
    "contracts/functions/dapps/FMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {MCD_MANAGER} from \"../../constants/CMaker.sol\";\nimport {INSTA_MAPPING} from \"../../constants/CInstaDapp.sol\";\nimport {\n    ITokenJoinInterface\n} from \"../../interfaces/dapps/Maker/ITokenJoinInterface.sol\";\nimport {IMcdManager} from \"../../interfaces/dapps/Maker/IMcdManager.sol\";\nimport {InstaMapping} from \"../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {IVat} from \"../../interfaces/dapps/Maker/IVat.sol\";\nimport {RAY, add, sub, mul} from \"../../vendor/DSMath.sol\";\nimport {_stringToBytes32, _convertTo18} from \"../../vendor/Convert.sol\";\n\nfunction _getMakerVaultDebt(uint256 _vaultId) view returns (uint256 wad) {\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    IVat vat = IVat(manager.vat());\n    (, uint256 rate, , , ) = vat.ilks(ilk);\n    (, uint256 art) = vat.urns(ilk, urn);\n    uint256 dai = vat.dai(urn);\n\n    uint256 rad = sub(mul(art, rate), dai);\n    wad = rad / RAY;\n\n    wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n}\n\nfunction _getMakerRawVaultDebt(uint256 _vaultId) view returns (uint256 tab) {\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    IVat vat = IVat(manager.vat());\n    (, uint256 rate, , , ) = vat.ilks(ilk);\n    (, uint256 art) = vat.urns(ilk, urn);\n\n    uint256 rad = mul(art, rate);\n\n    tab = rad / RAY;\n    tab = mul(tab, RAY) < rad ? tab + 1 : tab;\n}\n\nfunction _getMakerVaultCollateralBalance(uint256 _vaultId)\n    view\n    returns (uint256)\n{\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    IVat vat = IVat(manager.vat());\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    (uint256 ink, ) = vat.urns(ilk, urn);\n\n    return ink;\n}\n\nfunction _vaultWillBeSafe(\n    uint256 _vaultId,\n    uint256 _colAmt,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    require(_vaultId != 0, \"_vaultWillBeSafe: invalid vault id.\");\n\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n\n    ITokenJoinInterface tokenJoinContract =\n        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\n\n    IVat vat = IVat(manager.vat());\n    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\n    (uint256 ink, uint256 art) = vat.urns(ilk, urn);\n    uint256 dai = vat.dai(urn);\n\n    uint256 dink = _convertTo18(tokenJoinContract.dec(), _colAmt);\n    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\n\n    ink = add(ink, dink);\n    art = add(art, dart);\n\n    uint256 tab = mul(rate, art);\n\n    return tab <= mul(ink, spot);\n}\n\nfunction _newVaultWillBeSafe(\n    string memory _colType,\n    uint256 _colAmt,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n    IVat vat = IVat(manager.vat());\n\n    bytes32 ilk = _stringToBytes32(_colType);\n\n    (, uint256 rate, uint256 spot, , ) = vat.ilks(ilk);\n\n    ITokenJoinInterface tokenJoinContract =\n        ITokenJoinInterface(InstaMapping(INSTA_MAPPING).gemJoinMapping(ilk));\n\n    uint256 ink = _convertTo18(tokenJoinContract.dec(), _colAmt);\n    uint256 art = _getDebtAmt(_daiDebtAmt, 0, rate);\n\n    uint256 tab = mul(rate, art);\n\n    return tab <= mul(ink, spot);\n}\n\nfunction _debtCeilingIsReachedNewVault(\n    string memory _colType,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n    IVat vat = IVat(manager.vat());\n\n    bytes32 ilk = _stringToBytes32(_colType);\n\n    (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\n    uint256 Line = vat.Line();\n    uint256 debt = vat.debt();\n\n    uint256 dart = _getDebtAmt(_daiDebtAmt, 0, rate);\n    uint256 dtab = mul(rate, dart);\n\n    debt = add(debt, dtab);\n    Art = add(Art, dart);\n\n    return mul(Art, rate) > line || debt > Line;\n}\n\nfunction _debtCeilingIsReached(uint256 _vaultId, uint256 _daiDebtAmt)\n    view\n    returns (bool)\n{\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n    IVat vat = IVat(manager.vat());\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n\n    (uint256 Art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\n    uint256 dai = vat.dai(urn);\n    uint256 Line = vat.Line();\n    uint256 debt = vat.debt();\n\n    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\n    uint256 dtab = mul(rate, dart);\n\n    debt = add(debt, dtab);\n    Art = add(Art, dart);\n\n    return mul(Art, rate) > line || debt > Line;\n}\n\nfunction _debtIsDustNewVault(string memory _colType, uint256 _daiDebtAmt)\n    view\n    returns (bool)\n{\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n    IVat vat = IVat(manager.vat());\n\n    bytes32 ilk = _stringToBytes32(_colType);\n\n    (, uint256 rate, , , uint256 dust) = vat.ilks(ilk);\n    uint256 art = _getDebtAmt(_daiDebtAmt, 0, rate);\n\n    uint256 tab = mul(rate, art);\n\n    return tab < dust;\n}\n\nfunction _debtIsDust(uint256 _vaultId, uint256 _daiDebtAmt)\n    view\n    returns (bool)\n{\n    IMcdManager manager = IMcdManager(MCD_MANAGER);\n    IVat vat = IVat(manager.vat());\n\n    (bytes32 ilk, address urn) = _getVaultData(manager, _vaultId);\n    (, uint256 art) = vat.urns(ilk, urn);\n    (, uint256 rate, , , uint256 dust) = vat.ilks(ilk);\n\n    uint256 dai = vat.dai(urn);\n    uint256 dart = _getDebtAmt(_daiDebtAmt, dai, rate);\n    art = add(art, dart);\n    uint256 tab = mul(rate, art);\n\n    return tab < dust;\n}\n\nfunction _getVaultData(IMcdManager _manager, uint256 _vault)\n    view\n    returns (bytes32 ilk, address urn)\n{\n    ilk = _manager.ilks(_vault);\n    urn = _manager.urns(_vault);\n}\n\nfunction _getDebtAmt(\n    uint256 _amt,\n    uint256 _dai,\n    uint256 _rate\n) pure returns (uint256 dart) {\n    dart = sub(mul(_amt, RAY), _dai) / _rate;\n    dart = mul(dart, _rate) < mul(_amt, RAY) ? dart + 1 : dart;\n}\n\nfunction _isVaultOwner(uint256 _vaultId, address _owner) view returns (bool) {\n    if (_vaultId == 0) return false;\n\n    try IMcdManager(MCD_MANAGER).owns(_vaultId) returns (address owner) {\n        return _owner == owner;\n    } catch Error(string memory error) {\n        revert(string(abi.encodePacked(\"FMaker._isVaultOwner:\", error)));\n    } catch {\n        revert(\"FMaker._isVaultOwner:undefined\");\n    }\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FInstaPoolV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectInstaPoolV2\n} from \"../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\n\nfunction _encodeFlashPayback(\n    address _token,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashPayback.selector,\n            _token,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectMaker\n} from \"../../../interfaces/InstaDapp/connectors/IConnectMaker.sol\";\n\nfunction _encodeOpenMakerVault(string memory _colType)\n    pure\n    returns (bytes memory)\n{\n    return abi.encodeWithSelector(IConnectMaker.open.selector, _colType);\n}\n\nfunction _encodeBorrowMakerVault(\n    uint256 _vaultId,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectMaker.borrow.selector,\n            _vaultId,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n\nfunction _encodedDepositMakerVault(\n    uint256 _vaultId,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectMaker.deposit.selector,\n            _vaultId,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n\nfunction _encodePaybackMakerVault(\n    uint256 _vaultId,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectMaker.payback.selector,\n            _vaultId,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n\nfunction _encodedWithdrawMakerVault(\n    uint256 _vaultId,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectMaker.withdraw.selector,\n            _vaultId,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectAave\n} from \"../../../interfaces/InstaDapp/connectors/IConnectAave.sol\";\n\nfunction _encodeDepositAave(\n    address _token,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectAave.deposit.selector,\n            _token,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n\nfunction _encodeBorrowAave(\n    address _token,\n    uint256 _amt,\n    uint256 _rateMode, // 1 for Stable and 2 for variable\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectAave.borrow.selector,\n            _token,\n            _amt,\n            _rateMode,\n            _getId,\n            _setId\n        );\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectDebtBridgeFee\n} from \"../../../interfaces/InstaDapp/connectors/IConnectDebtBridgeFee.sol\";\n\nfunction _encodeCalculateFee(\n    uint256 _amount,\n    uint256 _ftf,\n    uint256 _fee,\n    uint256 _getId,\n    uint256 _setId,\n    uint256 _setIdFee\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectDebtBridgeFee.calculateFee.selector,\n            _amount,\n            _ftf,\n            _fee,\n            _getId,\n            _setId,\n            _setIdFee\n        );\n}\n"
    },
    "contracts/functions/gelato/FGelato.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GELATO_GAS_PRICE_ORACLE} from \"../../constants/CGelato.sol\";\nimport {mul} from \"../../vendor/DSMath.sol\";\n\nfunction _getGelatoGasPrice() view returns (uint256) {\n    int256 oracleGasPrice = GELATO_GAS_PRICE_ORACLE.latestAnswer();\n    if (oracleGasPrice <= 0) revert(\"_getGelatoGasPrice:0orBelow\");\n    return uint256(oracleGasPrice);\n}\n\nfunction _getGelatoExecutorFees(uint256 _gas) view returns (uint256) {\n    return mul(_gas, _getGelatoGasPrice());\n}\n"
    },
    "contracts/functions/gelato/FGelatoDebtBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {wmul, wdiv} from \"../../vendor/DSMath.sol\";\nimport {\n    INSTA_POOL_RESOLVER,\n    ROUTE_1_TOLERANCE\n} from \"../../constants/CInstaDapp.sol\";\nimport {DebtBridgeInputData} from \"../../structs/SDebtBridge.sol\";\nimport {\n    _canDoMakerToAaveDebtBridge,\n    _canDoMakerToMakerDebtBridge,\n    _canDoMakerToCompoundDebtBridge\n} from \"./conditions/FCanDoRefinance.sol\";\nimport {\n    PROTOCOL,\n    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER,\n    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND,\n    GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE,\n    FAST_TX_FEE,\n    VAULT_CREATION_COST\n} from \"../../constants/CDebtBridge.sol\";\nimport {\n    IInstaPoolResolver\n} from \"../../interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol\";\n\nfunction _getFlashLoanRoute(address _debtToken, uint256 _debtAmt)\n    view\n    returns (uint256)\n{\n    IInstaPoolResolver.RouteData memory rData =\n        IInstaPoolResolver(INSTA_POOL_RESOLVER).getTokenLimit(_debtToken);\n\n    if (rData.dydx > _debtAmt) return 0;\n    if (rData.maker > _debtAmt) return 1;\n    if (rData.compound > _debtAmt) return 2;\n    if (rData.aave > _debtAmt) return 3;\n    revert(\"FGelatoDebtBridge._getFlashLoanRoute: illiquid\");\n}\n\nfunction _getDebtBridgeRoute(DebtBridgeInputData memory _data)\n    view\n    returns (PROTOCOL)\n{\n    if (_canDoMakerToAaveDebtBridge(_data)) return PROTOCOL.AAVE;\n    else if (_canDoMakerToMakerDebtBridge(_data)) return PROTOCOL.MAKER;\n    else if (_canDoMakerToCompoundDebtBridge(_data)) return PROTOCOL.COMPOUND;\n    return PROTOCOL.NONE;\n}\n\nfunction _getGasCostMakerToMaker(bool _newVault, uint256 _route)\n    pure\n    returns (uint256)\n{\n    _checkRouteIndex(\n        _route,\n        \"FGelatoDebtBridge._getGasCostMakerToMaker: invalid route index\"\n    );\n    return\n        _getGasCostPremium(\n            _newVault\n                ? GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()[_route] +\n                    VAULT_CREATION_COST\n                : GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()[_route]\n        );\n}\n\nfunction _getGasCostMakerToCompound(uint256 _route) pure returns (uint256) {\n    _checkRouteIndex(\n        _route,\n        \"FGelatoDebtBridge._getGasCostMakerToCompound: invalid route index\"\n    );\n    return\n        _getGasCostPremium(\n            GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND()[_route]\n        );\n}\n\nfunction _getGasCostMakerToAave(uint256 _route) pure returns (uint256) {\n    _checkRouteIndex(\n        _route,\n        \"FGelatoDebtBridge._getGasCostMakerToAave: invalid route index\"\n    );\n    return\n        _getGasCostPremium(\n            GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE()[_route]\n        );\n}\n\nfunction _getGasCostPremium(uint256 _rawGasCost) pure returns (uint256) {\n    return (_rawGasCost * (100 + FAST_TX_FEE)) / 100;\n}\n\nfunction _getRealisedDebt(uint256 _debtToMove) pure returns (uint256) {\n    return wmul(_debtToMove, ROUTE_1_TOLERANCE);\n}\n\nfunction _checkRouteIndex(uint256 _route, string memory _revertMsg) pure {\n    require(_route <= 4, _revertMsg);\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {IGelatoProviderModule} from \"../../gelato_provider_modules/IGelatoProviderModule.sol\";\nimport {IGelatoCondition} from \"../../gelato_conditions/IGelatoCondition.sol\";\n\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nenum DataFlow { None, In, Out, InAndOut }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    DataFlow dataFlow;\n    uint256 value;\n    bool termsOkCheck;\n}\n\nstruct Task {\n    Condition[] conditions;  // optional\n    Action[] actions;\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\n}\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Provider provider;\n    uint256 index;\n    Task[] tasks;\n    uint256 expiryDate;\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\n    uint256 submissionsLeft;\n}\n\ninterface IGelatoCore {\n    event LogTaskSubmitted(\n        uint256 indexed taskReceiptId,\n        bytes32 indexed taskReceiptHash,\n        TaskReceipt taskReceipt\n    );\n\n    event LogExecSuccess(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorSuccessFee,\n        uint256 sysAdminSuccessFee\n    );\n    event LogCanExecFailed(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        string reason\n    );\n    event LogExecReverted(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorRefund,\n        string reason\n    );\n\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\n\n    /// @notice API to query whether Task can be submitted successfully.\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _userProxy The userProxy from which the task will be submitted.\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\n    function canSubmitTask(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external\n        view\n        returns(string memory);\n\n    /// @notice API to submit a single Task.\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task A Gelato Task object: provider, conditions, actions.\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\n    function submitTask(\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _cycles How many full cycles will be submitted\n    function submitTaskCycle(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _cycles\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\n    ///  would be submitted, but not the second\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n    ///  that should have occured once the cycle is complete:\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\n    ///  ...\n    function submitTaskChain(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _sumOfRequestedTaskSubmits\n    )\n        external;\n\n    // ================  Exec Suite =========================\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n    ///   In the latter case Executors are refunded by the Task Provider.\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function exec(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel task\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function cancelTask(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel multiple tasks at once\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n\n    /// @notice Compute hash of task receipt\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @return hash of taskReceipt\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\n\n    // ================  Getters =========================\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n    /// @return currentId currentId, last TaskReceiptId submitted\n    function currentTaskReceiptId() external view returns(uint256);\n\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n    /// @return hash of taskReceipt\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\n}\n"
    },
    "contracts/interfaces/gelato/IOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IOracleAggregator {\n    function getExpectedReturnAmount(\n        uint256 amount,\n        address tokenAddressA,\n        address tokenAddressB\n    ) external view returns (uint256 returnAmount, uint256 decimals);\n}\n"
    },
    "contracts/contracts/connectors/base/BInstaFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IBInstaFeeCollector\n} from \"../../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\nimport {\n    Ownable\n} from \"../../../vendor/openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract BInstaFeeCollector is IBInstaFeeCollector, Ownable {\n    uint256 public immutable override fee;\n\n    address payable public override feeCollector;\n    uint256 public override minDebt;\n\n    address internal immutable _connectGelatoDebtBridgeFee;\n\n    constructor(\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    ) {\n        fee = _fee;\n        feeCollector = _feeCollector;\n        minDebt = _minDebt;\n        _connectGelatoDebtBridgeFee = __connectGelatoDebtBridgeFee;\n    }\n\n    function setFeeCollector(address payable _feeCollector)\n        external\n        override\n        onlyOwner\n    {\n        feeCollector = _feeCollector;\n    }\n\n    function setMinDebt(uint256 _minDebt) external override onlyOwner {\n        minDebt = _minDebt;\n    }\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectBasic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectBasic\n} from \"../../../interfaces/InstaDapp/connectors/IConnectBasic.sol\";\n\nfunction _encodeBasicWithdraw(\n    address _erc20,\n    uint256 _tokenAmt,\n    address payable _to,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectBasic.withdraw.selector,\n            _erc20,\n            _tokenAmt,\n            _to,\n            _getId,\n            _setId\n        );\n}\n"
    },
    "contracts/constants/CMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\naddress constant MCD_MANAGER = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n"
    },
    "contracts/interfaces/dapps/Maker/ITokenJoinInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ITokenJoinInterface {\n    function dec() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/dapps/Maker/IMcdManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IMcdManager {\n    function ilks(uint256) external view returns (bytes32);\n\n    function urns(uint256) external view returns (address);\n\n    function vat() external view returns (address);\n\n    function owns(uint256) external view returns (address);\n}\n"
    },
    "contracts/interfaces/dapps/Maker/IVat.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IVat {\n    function ilks(bytes32)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function dai(address) external view returns (uint256);\n\n    function urns(bytes32, address) external view returns (uint256, uint256);\n\n    function debt() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function Line() external view returns (uint256);\n}\n"
    },
    "contracts/vendor/Convert.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {mul as _mul} from \"./DSMath.sol\";\n\nfunction _stringToBytes32(string memory str) pure returns (bytes32 result) {\n    require(bytes(str).length != 0, \"string-empty\");\n    assembly {\n        result := mload(add(str, 32))\n    }\n}\n\nfunction _convertTo18(uint256 _dec, uint256 _amt) pure returns (uint256 amt) {\n    amt = _mul(_amt, 10**(18 - _dec));\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectMaker {\n    function payback(\n        uint256 vault,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n\n    function borrow(\n        uint256 vault,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n\n    function open(string calldata colType)\n        external\n        payable\n        returns (uint256 vault);\n\n    function withdraw(\n        uint256 vault,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n\n    function deposit(\n        uint256 vault,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectAave {\n    function borrow(\n        address token,\n        uint256 amt,\n        uint256 _rateMode,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n\n    function deposit(\n        address token,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectDebtBridgeFee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectDebtBridgeFee {\n    function calculateFee(\n        uint256 _amount,\n        uint256 _ftf,\n        uint256 _fee,\n        uint256 _getId,\n        uint256 _setId,\n        uint256 _setIdFee\n    ) external payable;\n}\n"
    },
    "contracts/constants/CGelato.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IGelatoGasPriceOracle\n} from \"../interfaces/gelato/IGelatoGasPriceOracle.sol\";\n\nIGelatoGasPriceOracle constant GELATO_GAS_PRICE_ORACLE = IGelatoGasPriceOracle(\n    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\n);\n"
    },
    "contracts/interfaces/gelato/IGelatoGasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IGelatoGasPriceOracle {\n    function latestAnswer() external view returns (int256);\n}\n"
    },
    "contracts/structs/SDebtBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nstruct DebtBridgeInputData {\n    address dsa;\n    uint256 colAmt;\n    address debtToken;\n    uint256 debtAmt;\n    address priceOracle;\n    bytes oraclePayload;\n    uint256 makerDestVaultId;\n    string makerDestColType;\n}\n"
    },
    "contracts/functions/gelato/conditions/FCanDoRefinance.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {_isAaveLiquid} from \"./aave/FAaveHasLiquidity.sol\";\nimport {_aavePositionWillBeSafe} from \"./aave/FAavePositionWillBeSafe.sol\";\nimport {_isDebtAmtDust} from \"./maker/FIsDebtAmtDust.sol\";\nimport {_isDebtCeilingReached} from \"./maker/FDebtCeilingIsReached.sol\";\nimport {_destVaultWillBeSafe} from \"./maker/FDestVaultWillBeSafe.sol\";\nimport {_cTokenHasLiquidity} from \"./compound/FCompoundHasLiquidity.sol\";\nimport {\n    _compoundPositionWillBeSafe\n} from \"./compound/FCompoundPositionWillBeSafe.sol\";\nimport {DebtBridgeInputData} from \"../../../structs/SDebtBridge.sol\";\n\nfunction _canDoMakerToAaveDebtBridge(DebtBridgeInputData memory _data)\n    view\n    returns (bool)\n{\n    return\n        _isAaveLiquid(_data.debtToken, _data.debtAmt) &&\n        _aavePositionWillBeSafe(\n            _data.dsa,\n            _data.colAmt,\n            _data.debtToken,\n            _data.debtAmt,\n            _data.priceOracle,\n            _data.oraclePayload\n        );\n}\n\nfunction _canDoMakerToMakerDebtBridge(DebtBridgeInputData memory _data)\n    view\n    returns (bool)\n{\n    return\n        !_isDebtAmtDust(\n            _data.dsa,\n            _data.makerDestVaultId,\n            _data.makerDestColType,\n            _data.debtAmt\n        ) &&\n        !_isDebtCeilingReached(\n            _data.dsa,\n            _data.makerDestVaultId,\n            _data.makerDestColType,\n            _data.debtAmt\n        ) &&\n        _destVaultWillBeSafe(\n            _data.dsa,\n            _data.makerDestVaultId,\n            _data.makerDestColType,\n            _data.colAmt,\n            _data.debtAmt\n        );\n}\n\nfunction _canDoMakerToCompoundDebtBridge(DebtBridgeInputData memory _data)\n    view\n    returns (bool)\n{\n    return\n        _cTokenHasLiquidity(_data.debtToken, _data.debtAmt) &&\n        _compoundPositionWillBeSafe(\n            _data.dsa,\n            _data.colAmt,\n            _data.debtToken,\n            _data.debtAmt\n        );\n}\n"
    },
    "contracts/constants/CDebtBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nenum PROTOCOL {AAVE, MAKER, COMPOUND, NONE}\n\nfunction GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_MAKER()\n    pure\n    returns (uint256[4] memory)\n{\n    return [uint256(2519000), 3140500, 3971000, 4345000];\n}\n\nfunction GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_COMPOUND()\n    pure\n    returns (uint256[4] memory)\n{\n    return [uint256(2028307), 2626711, 2944065, 3698800];\n}\n\nfunction GAS_COSTS_FOR_FULL_REFINANCE_MAKER_TO_AAVE()\n    pure\n    returns (uint256[4] memory)\n{\n    return [uint256(2358534), 2956937, 3381960, 4029400];\n}\n\nuint256 constant FAST_TX_FEE = 30;\nuint256 constant VAULT_CREATION_COST = 200000;\n"
    },
    "contracts/interfaces/InstaDapp/resolvers/IInstaPoolResolver.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.8.0;\n\ninterface IInstaPoolResolver {\n    struct RouteData {\n        uint256 dydx;\n        uint256 maker;\n        uint256 compound;\n        uint256 aave;\n    }\n\n    function getTokenLimit(address token)\n        external\n        view\n        returns (RouteData memory);\n}\n"
    },
    "contracts/functions/gelato/conditions/aave/FAaveHasLiquidity.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {IERC20} from \"../../../../interfaces/dapps/IERC20.sol\";\nimport {\n    ILendingPoolAddressesProvider\n} from \"../../../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../../../interfaces/dapps/Aave/ILendingPool.sol\";\nimport {LENDING_POOL_ADDRESSES_PROVIDER} from \"../../../../constants/CAave.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {_getMakerVaultDebt} from \"../../../../functions/dapps/FMaker.sol\";\n\nfunction _isAaveLiquid(address _debtToken, uint256 _debtAmt)\n    view\n    returns (bool)\n{\n    return\n        IERC20(_debtToken).balanceOf(\n            ILendingPool(\n                ILendingPoolAddressesProvider(LENDING_POOL_ADDRESSES_PROVIDER)\n                    .getLendingPool()\n            )\n                .getReserveData(_debtToken)\n                .aTokenAddress\n        ) > _debtAmt;\n}\n"
    },
    "contracts/functions/gelato/conditions/aave/FAavePositionWillBeSafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _getPosition,\n    _percentDiv,\n    _collateralData\n} from \"../../../../functions/dapps/FAave.sol\";\nimport {AaveUserData, AaveTokenData} from \"../../../../structs/SAave.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {wdiv} from \"../../../../vendor/DSMath.sol\";\n\nfunction _aavePositionWillBeSafe(\n    address _dsa,\n    uint256 _colAmt,\n    address _debtToken,\n    uint256 _debtAmt,\n    address _priceOracle,\n    bytes memory _oraclePayload\n) view returns (bool) {\n    (bool success, bytes memory returndata) =\n        _priceOracle.staticcall(_oraclePayload);\n\n    if (!success) {\n        GelatoBytes.revertWithError(\n            returndata,\n            \"ConditionDestPositionWillBeSafe.destPositionIsSafe:oracle:\"\n        );\n    }\n\n    uint256 colPrice = abi.decode(returndata, (uint256));\n\n    AaveUserData memory userData = _getPosition(_dsa);\n    AaveTokenData memory tokenData = _collateralData(_debtToken);\n\n    // TODO: check token decimal precision given by the oracle for other token.\n    return\n        _percentDiv(\n            userData.totalBorrowsETH + wdiv(_debtAmt, colPrice),\n            (userData.totalCollateralETH + _colAmt)\n        ) <= tokenData.ltv;\n}\n"
    },
    "contracts/functions/gelato/conditions/maker/FIsDebtAmtDust.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _debtIsDustNewVault,\n    _debtIsDust,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\n\nfunction _isDebtAmtDust(\n    address _dsa,\n    uint256 _destVaultId,\n    string memory _destColType,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\n\n    return _isDebtAmtDustExplicit(_destVaultId, _destColType, _daiDebtAmt);\n}\n\nfunction _isDebtAmtDustExplicit(\n    uint256 _destVaultId,\n    string memory _destColType,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    return\n        _destVaultId == 0\n            ? _debtIsDustNewVault(_destColType, _daiDebtAmt)\n            : _debtIsDust(_destVaultId, _daiDebtAmt);\n}\n"
    },
    "contracts/functions/gelato/conditions/maker/FDebtCeilingIsReached.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _debtCeilingIsReachedNewVault,\n    _debtCeilingIsReached,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\n\nfunction _isDebtCeilingReached(\n    address _dsa,\n    uint256 _destVaultId,\n    string memory _destColType,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\n\n    return\n        _debtCeilingIsReachedExplicit(_destVaultId, _destColType, _daiDebtAmt);\n}\n\nfunction _debtCeilingIsReachedExplicit(\n    uint256 _destVaultId,\n    string memory _destColType,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    return\n        _destVaultId == 0\n            ? _debtCeilingIsReachedNewVault(_destColType, _daiDebtAmt)\n            : _debtCeilingIsReached(_destVaultId, _daiDebtAmt);\n}\n"
    },
    "contracts/functions/gelato/conditions/maker/FDestVaultWillBeSafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _vaultWillBeSafe,\n    _newVaultWillBeSafe,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\n\nfunction _destVaultWillBeSafe(\n    address _dsa,\n    uint256 _destVaultId,\n    string memory _destColType,\n    uint256 _colAmt,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    _destVaultId = _isVaultOwner(_destVaultId, _dsa) ? _destVaultId : 0;\n\n    return\n        _destVaultWillBeSafeExplicit(\n            _destVaultId,\n            _destColType,\n            _colAmt,\n            _daiDebtAmt\n        );\n}\n\nfunction _destVaultWillBeSafeExplicit(\n    uint256 _destVaultId,\n    string memory _destColType,\n    uint256 _colAmt,\n    uint256 _daiDebtAmt\n) view returns (bool) {\n    return\n        _destVaultId == 0\n            ? _newVaultWillBeSafe(_destColType, _colAmt, _daiDebtAmt)\n            : _vaultWillBeSafe(_destVaultId, _colAmt, _daiDebtAmt);\n}\n"
    },
    "contracts/functions/gelato/conditions/compound/FCompoundHasLiquidity.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ICToken} from \"../../../../interfaces/dapps/Compound/ICToken.sol\";\nimport {_getCToken} from \"../../../dapps/FCompound.sol\";\n\nfunction _cTokenHasLiquidity(address _debtToken, uint256 _debtAmt)\n    view\n    returns (bool)\n{\n    return ICToken(_getCToken(_debtToken)).getCash() > _debtAmt;\n}\n"
    },
    "contracts/functions/gelato/conditions/compound/FCompoundPositionWillBeSafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    _getCToken,\n    _wouldCompoundAccountBeLiquid\n} from \"../../../dapps/FCompound.sol\";\n\nfunction _compoundPositionWillBeSafe(\n    address _dsa,\n    uint256 _colAmt,\n    address _debtToken,\n    uint256 _debtAmt\n) view returns (bool) {\n    return\n        _wouldCompoundAccountBeLiquid(\n            _dsa,\n            _colAmt,\n            _getCToken(_debtToken),\n            _debtAmt\n        );\n}\n"
    },
    "contracts/interfaces/dapps/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ILendingPoolAddressesProvider {\n    function getLendingPool() external view returns (address);\n\n    function getPriceOracle() external view returns (address);\n}\n"
    },
    "contracts/interfaces/dapps/Aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ReserveData} from \"../../../structs/SAave.sol\";\n\ninterface ILendingPool {\n    function getReserveData(address asset)\n        external\n        view\n        returns (ReserveData memory);\n\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n}\n"
    },
    "contracts/constants/CAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// Aave Lending Pool Addresses Provider\naddress constant LENDING_POOL_ADDRESSES_PROVIDER = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;\naddress constant CHAINLINK_ETH_FEED = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\naddress constant AAVE_PROTOCOL_DATA_PROVIDER = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;\n"
    },
    "contracts/structs/SAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// ////////// LendingPool /////////////////\nstruct AaveUserData {\n    uint256 totalCollateralETH;\n    uint256 totalBorrowsETH;\n    uint256 availableBorrowsETH;\n    uint256 currentLiquidationThreshold;\n    uint256 ltv;\n    uint256 healthFactor;\n    uint256 ethPriceInUsd;\n}\n\nstruct TokenPrice {\n    uint256 priceInEth;\n    uint256 priceInUsd;\n}\nstruct AaveTokenData {\n    uint256 ltv;\n    uint256 threshold;\n    uint256 reserveFactor;\n    bool usageAsCollEnabled;\n    bool borrowEnabled;\n    bool stableBorrowEnabled;\n    bool isActive;\n    bool isFrozen;\n}\n\nstruct ReserveConfigurationMap {\n    uint256 data;\n}\n\nstruct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    //tokens addresses\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint8 id;\n}\n"
    },
    "contracts/functions/dapps/FAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IAaveProtocolDataProvider\n} from \"../../interfaces/dapps/Aave/IAaveProtocolDataProvider.sol\";\nimport {\n    IAavePriceOracle\n} from \"../../interfaces/dapps/Aave/IAavePriceOracle.sol\";\nimport {\n    ILendingPoolAddressesProvider\n} from \"../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\";\nimport {\n    ChainLinkInterface\n} from \"../../interfaces/dapps/Aave/ChainLinkInterface.sol\";\nimport {ILendingPool} from \"../../interfaces/dapps/Aave/ILendingPool.sol\";\nimport {AaveUserData, AaveTokenData} from \"../../structs/SAave.sol\";\nimport {\n    LENDING_POOL_ADDRESSES_PROVIDER,\n    CHAINLINK_ETH_FEED,\n    AAVE_PROTOCOL_DATA_PROVIDER\n} from \"../../constants/CAave.sol\";\nimport {ETH, WETH} from \"../../constants/CTokens.sol\";\nimport {wmul} from \"../../vendor/DSMath.sol\";\n\nfunction _getEtherPrice() view returns (uint256 ethPrice) {\n    ethPrice = uint256(ChainLinkInterface(CHAINLINK_ETH_FEED).latestAnswer());\n}\n\nfunction _getUserData(\n    ILendingPool aave,\n    address user,\n    uint256 ethPriceInUsd\n) view returns (AaveUserData memory userData) {\n    (\n        uint256 totalCollateralETH,\n        uint256 totalDebtETH,\n        uint256 availableBorrowsETH,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    ) = aave.getUserAccountData(user);\n\n    userData = AaveUserData(\n        totalCollateralETH,\n        totalDebtETH,\n        availableBorrowsETH,\n        currentLiquidationThreshold,\n        ltv,\n        healthFactor,\n        ethPriceInUsd\n    );\n}\n\nfunction _getPosition(address user) view returns (AaveUserData memory) {\n    ILendingPoolAddressesProvider addrProvider =\n        ILendingPoolAddressesProvider(LENDING_POOL_ADDRESSES_PROVIDER);\n\n    uint256 ethPrice = _getEtherPrice();\n\n    return (\n        _getUserData(\n            ILendingPool(addrProvider.getLendingPool()),\n            user,\n            ethPrice\n        )\n    );\n}\n\nfunction _percentDiv(uint256 value, uint256 percentage) pure returns (uint256) {\n    require(percentage != 0, \"Division Error\");\n    uint256 percentageFactor = 1e4; //percentage plus two decimals\n    uint256 halfPercentage = percentage / 2;\n\n    require(\n        value <= (type(uint256).max - halfPercentage) / percentageFactor,\n        \"Multiplication Overflow\"\n    );\n\n    return (value * percentageFactor + halfPercentage) / percentage;\n}\n\nfunction _collateralData(address token)\n    view\n    returns (AaveTokenData memory aaveTokenData)\n{\n    IAaveProtocolDataProvider aaveData =\n        IAaveProtocolDataProvider(AAVE_PROTOCOL_DATA_PROVIDER);\n    (, aaveTokenData.ltv, , , , , , , , ) = aaveData\n        .getReserveConfigurationData(token);\n}\n"
    },
    "contracts/interfaces/dapps/Aave/IAaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IAaveProtocolDataProvider {\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n}\n"
    },
    "contracts/interfaces/dapps/Aave/IAavePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IAavePriceOracle {\n    function getAssetPrice(address _asset) external view returns (uint256);\n\n    function getAssetsPrices(address[] calldata _assets)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getSourceOfAsset(address _asset) external view returns (uint256);\n\n    function getFallbackOracle() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/dapps/Aave/ChainLinkInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ChainLinkInterface {\n    function latestAnswer() external view returns (int256);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/dapps/Compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ICToken {\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getCash() external view returns (uint256);\n}\n"
    },
    "contracts/functions/dapps/FCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {CompData, AccountLiquidityLocalVars} from \"../../structs/SCompound.sol\";\nimport {INSTA_MAPPING} from \"../../constants/CInstaDapp.sol\";\nimport {COMPTROLLER} from \"../../constants/CCompound.sol\";\nimport {InstaMapping} from \"../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {ICToken} from \"../../interfaces/dapps/Compound/ICToken.sol\";\nimport {IComptroller} from \"../../interfaces/dapps/Compound/IComptroller.sol\";\nimport {IPriceOracle} from \"../../interfaces/dapps/Compound/IPriceOracle.sol\";\nimport {mul} from \"../../vendor/DSMath.sol\";\n\nfunction _getCToken(address _token) view returns (address) {\n    return InstaMapping(INSTA_MAPPING).cTokenMapping(_token);\n}\n\nfunction _wouldCompoundAccountBeLiquid(\n    address _dsa,\n    uint256 _colAmt,\n    address _cTokenModify,\n    uint256 _debtAmt\n) view returns (bool) {\n    AccountLiquidityLocalVars memory vars;\n\n    IComptroller comptroller = IComptroller(COMPTROLLER);\n\n    ICToken[] memory assets = comptroller.getAssetsIn(_dsa);\n    for (uint256 i = 0; i < assets.length; i++) {\n        ICToken asset = assets[i];\n        // Read the balances and exchange rate from the cToken\n        vars = _getAssetLiquidity(vars, _dsa, asset);\n\n        // Calculate effects of interacting with cTokenModify\n        if (address(asset) == _cTokenModify) {\n            vars.sumCollateral = mulScalarTruncateAddUInt(\n                vars.tokensToDenom,\n                _colAmt,\n                vars.sumCollateral\n            );\n\n            // borrow effect\n            // sumBorrowPlusEffects += oraclePrice * debtAmt\n            vars.sumBorrowPlusEffects = mulScalarTruncateAddUInt(\n                vars.oraclePrice,\n                _debtAmt,\n                vars.sumBorrowPlusEffects\n            );\n        }\n    }\n\n    if (assets.length == 0) {\n        vars = _getAssetLiquidity(vars, _dsa, ICToken(_cTokenModify));\n\n        vars.sumCollateral = mulScalarTruncateAddUInt(\n            vars.tokensToDenom,\n            _colAmt,\n            vars.sumCollateral\n        );\n\n        vars.sumBorrowPlusEffects = mulScalarTruncateAddUInt(\n            vars.oraclePrice,\n            _debtAmt,\n            vars.sumBorrowPlusEffects\n        );\n    }\n\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) return true;\n    else return false;\n}\n\nfunction _getAssetLiquidity(\n    AccountLiquidityLocalVars memory vars,\n    address _dsa,\n    ICToken _asset\n) view returns (AccountLiquidityLocalVars memory) {\n    uint256 oErr;\n    IComptroller comptroller = IComptroller(COMPTROLLER);\n\n    // Read the balances and exchange rate from the cToken\n    (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRate) = ICToken(\n        _asset\n    )\n        .getAccountSnapshot(_dsa);\n    require(oErr == 0, \"_getAssetLiquidity: semi-opaque error code\");\n    (, vars.collateralFactor, ) = (comptroller.markets(address(_asset)));\n    vars.oraclePrice = IPriceOracle(IComptroller(COMPTROLLER).oracle())\n        .getUnderlyingPrice(_asset);\n    require(vars.oraclePrice != 0, \"\");\n\n    vars.tokensToDenom = mul_expScale(\n        mul_expScale(vars.collateralFactor, vars.exchangeRate),\n        vars.oraclePrice\n    );\n\n    vars.sumCollateral = mulScalarTruncateAddUInt(\n        vars.tokensToDenom,\n        vars.cTokenBalance,\n        vars.sumCollateral\n    );\n\n    vars.sumBorrowPlusEffects = mulScalarTruncateAddUInt(\n        vars.oraclePrice,\n        vars.borrowBalance,\n        vars.sumBorrowPlusEffects\n    );\n    return vars;\n}\n\n// Compound Math Function\n\nfunction mulScalarTruncateAddUInt(\n    uint256 _a,\n    uint256 _b,\n    uint256 _addend\n) pure returns (uint256) {\n    return mul_expScale(_a, _b) + _addend;\n}\n\nfunction mul_expScale(uint256 _a, uint256 _b) pure returns (uint256) {\n    return mul(_a, _b) / 1e18;\n}\n\n// Compound Math Function\n"
    },
    "contracts/structs/SCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nstruct AccountLiquidityLocalVars {\n    uint256 sumCollateral;\n    uint256 sumBorrowPlusEffects;\n    uint256 cTokenBalance;\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n    uint256 oraclePriceMantissa;\n    uint256 collateralFactor;\n    uint256 exchangeRate;\n    uint256 oraclePrice;\n    uint256 tokensToDenom;\n}\n\nstruct Market {\n    bool isListed;\n    uint256 collateralFactorMantissa;\n    mapping(address => bool) accountMembership;\n    bool isComped;\n}\n\nstruct CompData {\n    uint256 tokenPriceInEth;\n    uint256 tokenPriceInUsd;\n    uint256 exchangeRateStored;\n    uint256 balanceOfUser;\n    uint256 borrowBalanceStoredUser;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 collateralFactor;\n    bool isComped;\n}\n"
    },
    "contracts/constants/CCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\naddress constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n"
    },
    "contracts/interfaces/dapps/Compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ICToken} from \"./ICToken.sol\";\nimport {Market} from \"../../../structs/SCompound.sol\";\n\ninterface IComptroller {\n    function getAssetsIn(address account)\n        external\n        view\n        returns (ICToken[] memory);\n\n    function oracle() external view returns (address);\n\n    function markets(address cToken)\n        external\n        view\n        returns (\n            bool isListed,\n            uint256 collateralFactorMantissa,\n            bool isComped\n        );\n}\n"
    },
    "contracts/interfaces/dapps/Compound/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ICToken} from \"./ICToken.sol\";\n\ninterface IPriceOracle {\n    function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_provider_modules/IGelatoProviderModule.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {Action, Task} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\ninterface IGelatoProviderModule {\n\n    /// @notice Check if provider agrees to pay for inputted task receipt\n    /// @dev Enables arbitrary checks by provider\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @return \"OK\" if provider agrees\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Convert action specific payload into proxy specific payload\n    /// @dev Encoded multiple actions into a multisend\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\n    /// @return Encoded payload that will be used for low-level .call on user proxy\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n    function execPayload(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        address _provider,\n        Task calldata _task,\n        uint256 _cycleId\n    )\n        external\n        view\n        returns(bytes memory, bool checkReturndata);\n\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_conditions/IGelatoCondition.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n    ///  \"ok\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n    ///  source of Task identification.\n    /// @param _conditionData This is the Condition.data field developers must encode their\n    ///  Condition's specific parameters in.\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\n        external\n        view\n        returns(string memory);\n}"
    },
    "contracts/vendor/openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectBasic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectBasic {\n    function withdraw(\n        address _erc20,\n        uint256 _tokenAmt,\n        address payable _to,\n        uint256 _getId,\n        uint256 _setId\n    ) external payable;\n}\n"
    },
    "contracts/contracts/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    IConnectInstaPoolV2\n} from \"../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    CONNECT_MAKER,\n    INSTA_POOL_V2,\n    CONNECT_BASIC,\n    CONNECT_FEE\n} from \"../../../../constants/CInstaDapp.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\nimport {\n    _encodeFlashPayback\n} from \"../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol\";\nimport {\n    _encodePaybackMakerVault,\n    _encodedWithdrawMakerVault,\n    _encodeOpenMakerVault,\n    _encodedDepositMakerVault,\n    _encodeBorrowMakerVault\n} from \"../../../../functions/InstaDapp/connectors/FConnectMaker.sol\";\nimport {\n    _encodeBasicWithdraw\n} from \"../../../../functions/InstaDapp/connectors/FConnectBasic.sol\";\nimport {\n    _encodeCalculateFee\n} from \"../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\";\nimport {_getGelatoExecutorFees} from \"../../../../functions/gelato/FGelato.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToMaker,\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    IOracleAggregator\n} from \"../../../../interfaces/gelato/IOracleAggregator.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {BInstaFeeCollector} from \"../../base/BInstaFeeCollector.sol\";\nimport {\n    IBInstaFeeCollector\n} from \"../../../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\n\ncontract ConnectGelatoDataMakerToMaker is\n    ConnectorInterface,\n    BInstaFeeCollector\n{\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable const-name-snakecase\n    string public constant override name = \"ConnectGelatoDataMakerToMaker-v3.0\";\n    uint256 internal immutable _id;\n    address internal immutable _oracleAggregator;\n    address public immutable connectGelatoDataMakerToMakerAddr;\n\n    constructor(\n        uint256 __id,\n        address __oracleAggregator,\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    )\n        BInstaFeeCollector(\n            _fee,\n            _feeCollector,\n            _minDebt,\n            __connectGelatoDebtBridgeFee\n        )\n    {\n        _id = __id;\n        _oracleAggregator = __oracleAggregator;\n        connectGelatoDataMakerToMakerAddr = address(this);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    // Overriding IGelatoAction's function (optional)\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow,\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        uint256 vaultAId = abi.decode(_actionData[4:36], (uint256));\n\n        if (vaultAId == 0)\n            return \"ConnectGelatoDataMakerToMaker: Vault A Id is not valid\";\n        if (!_isVaultOwner(vaultAId, _dsa))\n            return \"ConnectGelatoDataMakerToMaker: Vault A not owned by dsa\";\n        if (_getMakerVaultDebt(vaultAId) < minDebt)\n            return \"ConnectGelatoDataMakerToMaker: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\n    /// @param _vaultBId Id of the vault B Collateral of the client.\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\n    function getDataAndCastMakerToMaker(\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        string calldata _colType,\n        address _colToken\n    ) external payable {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataMakerToMaker(_vaultAId, _vaultBId, _colType, _colToken);\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n        if (!success) {\n            returndata.revertWithError(\"ConnectGelatoDataMakerToMaker._cast:\");\n        }\n    }\n\n    /* solhint-disable function-max-lines */\n\n    function _dataMakerToMaker(\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        string calldata _colType,\n        address _colToken\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](1);\n        targets[0] = INSTA_POOL_V2;\n\n        _vaultBId = _isVaultOwner(_vaultBId, address(this)) ? _vaultBId : 0;\n\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\n        uint256 wColToWithdrawFromMaker =\n            _getMakerVaultCollateralBalance(_vaultAId);\n\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\n        (uint256 gasFeesPaidFromBor, ) =\n            IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n                _getGelatoExecutorFees(\n                    _getGasCostMakerToMaker(_vaultBId == 0, route)\n                ),\n                _colToken,\n                DAI\n            );\n\n        (address[] memory _targets, bytes[] memory _datas) =\n            _vaultBId == 0\n                ? _spellsMakerToNewMakerVault(\n                    _vaultAId,\n                    _colType,\n                    daiToBorrow,\n                    wColToWithdrawFromMaker,\n                    gasFeesPaidFromBor\n                )\n                : _spellsMakerToMaker(\n                    _vaultAId,\n                    _vaultBId,\n                    daiToBorrow,\n                    wColToWithdrawFromMaker,\n                    gasFeesPaidFromBor\n                );\n\n        datas = new bytes[](1);\n        datas[0] = abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n            DAI,\n            daiToBorrow,\n            route,\n            abi.encode(_targets, _datas)\n        );\n    }\n\n    function _spellsMakerToNewMakerVault(\n        uint256 _vaultAId,\n        string calldata _colType,\n        uint256 _daiDebtAmt,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](9);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_MAKER; // open new B vault\n        targets[4] = CONNECT_MAKER; // deposit\n        targets[5] = CONNECT_MAKER; // borrow\n        targets[6] = CONNECT_BASIC; // user pay fee to fee collector\n        targets[7] = CONNECT_BASIC; // user pay fast transaction fee to executor\n        targets[8] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](9);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodeOpenMakerVault(_colType);\n        datas[4] = _encodedDepositMakerVault(0, _colToWithdrawFromMaker, 0, 0);\n        datas[5] = _encodeBorrowMakerVault(0, 0, 600, 0);\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[7] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[8] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n    }\n\n    function _spellsMakerToMaker(\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        uint256 _daiDebtAmt,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](8);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_MAKER; // deposit\n        targets[4] = CONNECT_MAKER; // borrow\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n        targets[7] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](8);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodedDepositMakerVault(\n            _vaultBId,\n            _colToWithdrawFromMaker,\n            0,\n            0\n        );\n        datas[4] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\n        datas[5] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n    }\n\n    /* solhint-enable function-max-lines */\n}\n"
    },
    "contracts/contracts/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    IConnectInstaPoolV2\n} from \"../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    CONNECT_MAKER,\n    CONNECT_COMPOUND,\n    INSTA_POOL_V2,\n    CONNECT_BASIC,\n    CONNECT_FEE\n} from \"../../../../constants/CInstaDapp.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\nimport {\n    _encodeFlashPayback\n} from \"../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol\";\nimport {\n    _encodePaybackMakerVault,\n    _encodedWithdrawMakerVault\n} from \"../../../../functions/InstaDapp/connectors/FConnectMaker.sol\";\nimport {\n    _encodeDepositCompound,\n    _encodeBorrowCompound\n} from \"../../../../functions/InstaDapp/connectors/FConnectCompound.sol\";\nimport {\n    _encodeBasicWithdraw\n} from \"../../../../functions/InstaDapp/connectors/FConnectBasic.sol\";\nimport {\n    _encodeCalculateFee\n} from \"../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\";\nimport {_getGelatoExecutorFees} from \"../../../../functions/gelato/FGelato.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToCompound,\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    IOracleAggregator\n} from \"../../../../interfaces/gelato/IOracleAggregator.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {BInstaFeeCollector} from \"../../base/BInstaFeeCollector.sol\";\nimport {\n    IBInstaFeeCollector\n} from \"../../../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\n\ncontract ConnectGelatoDataMakerToCompound is\n    ConnectorInterface,\n    BInstaFeeCollector\n{\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable const-name-snakecase\n    string public constant override name =\n        \"ConnectGelatoDataMakerToCompound-v1.0\";\n    uint256 internal immutable _id;\n    address internal immutable _oracleAggregator;\n    address public immutable connectGelatoDataMakerToCompoundAddr;\n\n    constructor(\n        uint256 __id,\n        address __oracleAggregator,\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    )\n        BInstaFeeCollector(\n            _fee,\n            _feeCollector,\n            _minDebt,\n            __connectGelatoDebtBridgeFee\n        )\n    {\n        _id = __id;\n        _oracleAggregator = __oracleAggregator;\n        connectGelatoDataMakerToCompoundAddr = address(this);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    /// @notice GelatoCore protocol standard function\n    /// @dev GelatoCore calls this to verify that a Task is executable\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow, // DataFlow\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        uint256 vaultId = abi.decode(_actionData[4:36], (uint256));\n\n        if (vaultId == 0)\n            return \"ConnectGelatoDataMakerToCompound: Vault Id is not valid\";\n        if (!_isVaultOwner(vaultId, _dsa))\n            return \"ConnectGelatoDataMakerToCompound: Vault not owned by dsa\";\n        if (_getMakerVaultDebt(vaultId) < minDebt)\n            return \"ConnectGelatoDataMakerToCompound: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _vaultId Id of the unsafe vault of the client.\n    /// @param _colToken  vault's col token address .\n    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\n        external\n        payable\n    {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataMakerToCompound(_vaultId, _colToken);\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n        if (!success) {\n            returndata.revertWithError(\n                \"ConnectGelatoDataMakerToCompound._cast:\"\n            );\n        }\n    }\n\n    /* solhint-disable function-max-lines */\n\n    function _dataMakerToCompound(uint256 _vaultId, address _colToken)\n        internal\n        view\n        returns (address[] memory targets, bytes[] memory datas)\n    {\n        targets = new address[](1);\n        targets[0] = INSTA_POOL_V2;\n\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\n\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\n        (uint256 gasFeesPaidFromBor, ) =\n            IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n                _getGelatoExecutorFees(_getGasCostMakerToCompound(route)),\n                _colToken,\n                DAI\n            );\n\n        (address[] memory _targets, bytes[] memory _datas) =\n            _spellsMakerToCompound(\n                _vaultId,\n                _colToken,\n                daiToBorrow,\n                _getMakerVaultCollateralBalance(_vaultId),\n                gasFeesPaidFromBor\n            );\n\n        datas = new bytes[](1);\n        datas[0] = abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n            DAI,\n            daiToBorrow,\n            route,\n            abi.encode(_targets, _datas)\n        );\n    }\n\n    function _spellsMakerToCompound(\n        uint256 _vaultId,\n        address _colToken,\n        uint256 _daiDebtAmt,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](8);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_COMPOUND; // deposit\n        targets[4] = CONNECT_COMPOUND; // borrow\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n        targets[7] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](8);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToCompoundAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodeDepositCompound(\n            _colToken,\n            _colToWithdrawFromMaker,\n            0,\n            0\n        );\n        datas[4] = _encodeBorrowCompound(DAI, 0, 600, 0);\n        datas[5] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToCompoundAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n    }\n\n    /* solhint-enable function-max-lines */\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectCompound\n} from \"../../../interfaces/InstaDapp/connectors/IConnectCompound.sol\";\n\nfunction _encodeDepositCompound(\n    address _token,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectCompound.deposit.selector,\n            _token,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n\nfunction _encodeBorrowCompound(\n    address _token,\n    uint256 _amt,\n    uint256 _getId,\n    uint256 _setId\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectCompound.borrow.selector,\n            _token,\n            _amt,\n            _getId,\n            _setId\n        );\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectCompound {\n    function borrow(\n        address token,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n\n    function deposit(\n        address token,\n        uint256 amt,\n        uint256 getId,\n        uint256 setId\n    ) external payable;\n}\n"
    },
    "contracts/contracts/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {sub} from \"../../../../vendor/DSMath.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    IConnectInstaPoolV2\n} from \"../../../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\nimport {\n    IBInstaFeeCollector\n} from \"../../../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    CONNECT_MAKER,\n    CONNECT_AAVE_V2,\n    CONNECT_BASIC,\n    INSTA_POOL_V2\n} from \"../../../../constants/CInstaDapp.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\nimport {\n    _encodeFlashPayback\n} from \"../../../../functions/InstaDapp/connectors/FInstaPoolV2.sol\";\nimport {\n    _encodePaybackMakerVault,\n    _encodedWithdrawMakerVault\n} from \"../../../../functions/InstaDapp/connectors/FConnectMaker.sol\";\nimport {\n    _encodeDepositAave,\n    _encodeBorrowAave\n} from \"../../../../functions/InstaDapp/connectors/FConnectAave.sol\";\nimport {\n    _encodeCalculateFee\n} from \"../../../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\";\nimport {_getGelatoExecutorFees} from \"../../../../functions/gelato/FGelato.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToAave,\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IOracleAggregator\n} from \"../../../../interfaces/gelato/IOracleAggregator.sol\";\nimport {\n    BInstaFeeCollector\n} from \"../../../../contracts/connectors/base/BInstaFeeCollector.sol\";\nimport {\n    _encodeBasicWithdraw\n} from \"../../../../functions/InstaDapp/connectors/FConnectBasic.sol\";\n\ncontract ConnectGelatoDataMakerToAave is\n    ConnectorInterface,\n    BInstaFeeCollector\n{\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable const-name-snakecase\n    string public constant override name = \"ConnectGelatoDataMakerToAave-v1.0\";\n    uint256 internal immutable _id;\n    address internal immutable _oracleAggregator;\n    address public immutable connectGelatoDataMakerToAaveAddr;\n\n    constructor(\n        uint256 __id,\n        address __oracleAggregator,\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    )\n        BInstaFeeCollector(\n            _fee,\n            _feeCollector,\n            _minDebt,\n            __connectGelatoDebtBridgeFee\n        )\n    {\n        _id = __id;\n        _oracleAggregator = __oracleAggregator;\n        connectGelatoDataMakerToAaveAddr = address(this);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    // Overriding IGelatoAction's function (optional)\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow,\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        uint256 vaultId = abi.decode(_actionData[4:36], (uint256));\n\n        if (vaultId == 0)\n            return \"ConnectGelatoDataMakerToAave: Vault Id is not valid\";\n        if (!_isVaultOwner(vaultId, _dsa))\n            return \"ConnectGelatoDataMakerToAave: Vault not owned by dsa\";\n        if (_getMakerVaultDebt(vaultId) < minDebt)\n            return \"ConnectGelatoDataMakerToAave: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _vaultId Id of the unsafe vault of the client of Vault A Collateral.\n    /// @param _colToken  vault's col token address .\n    function getDataAndCastMakerToAave(uint256 _vaultId, address _colToken)\n        external\n        payable\n    {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataMakerToAave(_vaultId, _colToken);\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n        if (!success) {\n            returndata.revertWithError(\"ConnectGelatoDataMakerToAave._cast:\");\n        }\n    }\n\n    /* solhint-disable function-max-lines */\n\n    function _dataMakerToAave(uint256 _vaultId, address _colToken)\n        internal\n        view\n        returns (address[] memory targets, bytes[] memory datas)\n    {\n        targets = new address[](1);\n        targets[0] = INSTA_POOL_V2;\n\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\n\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\n        (uint256 gasFeesPaidFromBor, ) =\n            IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n                _getGelatoExecutorFees(_getGasCostMakerToAave(route)),\n                _colToken,\n                DAI\n            );\n\n        (address[] memory _targets, bytes[] memory _datas) =\n            _spellsMakerToAave(\n                _vaultId,\n                _colToken,\n                daiToBorrow,\n                _getMakerVaultCollateralBalance(_vaultId),\n                gasFeesPaidFromBor\n            );\n\n        datas = new bytes[](1);\n        datas[0] = abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n            DAI,\n            daiToBorrow,\n            route,\n            abi.encode(_targets, _datas)\n        );\n    }\n\n    function _spellsMakerToAave(\n        uint256 _vaultId,\n        address _colToken,\n        uint256 _daiDebtAmt,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](8);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_AAVE_V2; // deposit\n        targets[4] = CONNECT_AAVE_V2; // borrow\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n        targets[7] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](8);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToAaveAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodeDepositAave(_colToken, _colToWithdrawFromMaker, 0, 0);\n        datas[4] = _encodeBorrowAave(DAI, 0, 2, 600, 0); // Variable rate by default.\n        datas[5] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToAaveAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n    }\n\n    /* solhint-enable function-max-lines */\n}\n"
    },
    "contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\nimport {sub} from \"../../vendor/DSMath.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    IConnectInstaPoolV2\n} from \"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\nimport {\n    IBInstaFeeCollector\n} from \"../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\nimport {DAI} from \"../../constants/CTokens.sol\";\nimport {\n    CONNECT_MAKER,\n    CONNECT_BASIC,\n    INSTA_POOL_V2\n} from \"../../constants/CInstaDapp.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../functions/dapps/FMaker.sol\";\nimport {\n    _encodeFlashPayback\n} from \"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\";\nimport {\n    _encodePaybackMakerVault,\n    _encodedWithdrawMakerVault,\n    _encodedDepositMakerVault,\n    _encodeBorrowMakerVault,\n    _encodeOpenMakerVault\n} from \"../../functions/InstaDapp/connectors/FConnectMaker.sol\";\nimport {\n    _encodeCalculateFee\n} from \"../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\";\nimport {_getGelatoExecutorFees} from \"../../functions/gelato/FGelato.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToMaker,\n    _getRealisedDebt\n} from \"../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {IOracleAggregator} from \"../../interfaces/gelato/IOracleAggregator.sol\";\nimport {\n    BInstaFeeCollector\n} from \"../../contracts/connectors/base/BInstaFeeCollector.sol\";\nimport {\n    _encodeBasicWithdraw\n} from \"../../functions/InstaDapp/connectors/FConnectBasic.sol\";\n\ncontract MockConnectGelatoDataMakerToMaker is\n    ConnectorInterface,\n    BInstaFeeCollector\n{\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable const-name-snakecase\n    string public constant override name = \"ConnectGelatoDataMakerToMaker-v3.0\";\n    uint256 internal immutable _id;\n    address internal immutable _oracleAggregator;\n    address public immutable connectGelatoDataMakerToMakerAddr;\n\n    constructor(\n        uint256 __id,\n        address __oracleAggregator,\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    )\n        BInstaFeeCollector(\n            _fee,\n            _feeCollector,\n            _minDebt,\n            __connectGelatoDebtBridgeFee\n        )\n    {\n        _id = __id;\n        _oracleAggregator = __oracleAggregator;\n        connectGelatoDataMakerToMakerAddr = address(this);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    // Overriding IGelatoAction's function (optional)\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow,\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        (, uint256 vaultAId, , , ) =\n            abi.decode(\n                _actionData[4:],\n                (uint256, uint256, uint256, string, address)\n            );\n\n        if (vaultAId == 0)\n            return \"ConnectGelatoDataMakerToMaker: Vault A Id is not valid\";\n        if (!_isVaultOwner(vaultAId, _dsa))\n            return \"ConnectGelatoDataMakerToMaker: Vault A not owned by dsa\";\n        if (_getMakerVaultCollateralBalance(vaultAId) < minDebt)\n            return \"ConnectGelatoDataMakerToMaker: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _mockRoute mock route Id.\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\n    /// @param _vaultBId Id of the vault B Collateral of the client.\n    /// @param _colType colType of the new vault. example : ETH-B, ETH-A.\n    function getDataAndCastMakerToMaker(\n        uint256 _mockRoute,\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        string calldata _colType,\n        address _colToken\n    ) external payable {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataMakerToMaker(\n                _mockRoute,\n                _vaultAId,\n                _vaultBId,\n                _colType,\n                _colToken\n            );\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n        if (!success) {\n            returndata.revertWithError(\"ConnectGelatoDataMakerToMaker._cast:\");\n        }\n    }\n\n    /* solhint-disable function-max-lines */\n\n    function _dataMakerToMaker(\n        uint256 _mockRoute,\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        string calldata _colType,\n        address _colToken\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](1);\n        targets[0] = INSTA_POOL_V2;\n\n        _vaultBId = _isVaultOwner(_vaultBId, address(this)) ? _vaultBId : 0;\n\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultAId));\n        uint256 wColToWithdrawFromMaker =\n            _getMakerVaultCollateralBalance(_vaultAId);\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\n        route = _mockRoute;\n        (uint256 gasFeesPaidFromBor, ) =\n            IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n                _getGelatoExecutorFees(\n                    _getGasCostMakerToMaker(_vaultBId == 0, route)\n                ),\n                _colToken,\n                DAI\n            );\n\n        (address[] memory _targets, bytes[] memory _datas) =\n            _vaultBId == 0\n                ? _spellsMakerToNewMakerVault(\n                    _vaultAId,\n                    _colType,\n                    daiToBorrow,\n                    wColToWithdrawFromMaker,\n                    gasFeesPaidFromBor\n                )\n                : _spellsMakerToMaker(\n                    _vaultAId,\n                    _vaultBId,\n                    daiToBorrow,\n                    wColToWithdrawFromMaker,\n                    gasFeesPaidFromBor\n                );\n\n        datas = new bytes[](1);\n        datas[0] = abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n            DAI,\n            daiToBorrow,\n            route,\n            abi.encode(_targets, _datas)\n        );\n    }\n\n    function _spellsMakerToNewMakerVault(\n        uint256 _vaultAId,\n        string calldata _colType,\n        uint256 _daiToBorrow,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](9);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_MAKER; // open new B vault\n        targets[4] = CONNECT_MAKER; // deposit\n        targets[5] = CONNECT_MAKER; // borrow\n        targets[6] = CONNECT_BASIC; // user pay fee to fee collector\n        targets[7] = CONNECT_BASIC; // user pay fast transaction fee to executor\n        targets[8] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](9);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodeOpenMakerVault(_colType);\n        datas[4] = _encodedDepositMakerVault(0, _colToWithdrawFromMaker, 0, 0);\n        datas[5] = _encodeBorrowMakerVault(0, 0, 600, 0);\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[7] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[8] = _encodeFlashPayback(DAI, _daiToBorrow, 0, 0);\n    }\n\n    function _spellsMakerToMaker(\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        uint256 _daiToBorrow,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](8);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_MAKER; // deposit\n        targets[4] = CONNECT_MAKER; // borrow\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n        targets[7] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](8);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultAId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodedDepositMakerVault(\n            _vaultBId,\n            _colToWithdrawFromMaker,\n            0,\n            0\n        );\n        datas[4] = _encodeBorrowMakerVault(_vaultBId, 0, 600, 0);\n        datas[5] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToMakerAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[7] = _encodeFlashPayback(DAI, _daiToBorrow, 0, 0);\n    }\n\n    /* solhint-enable function-max-lines */\n}\n"
    },
    "contracts/contracts/connectors/debt_bridge/from_maker/ConnectGelatoDataMakerToX.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\nimport {DebtBridgeInputData} from \"../../../../structs/SDebtBridge.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {PROTOCOL} from \"../../../../constants/CDebtBridge.sol\";\nimport {\n    _getDebtBridgeRoute\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    _encodeGetDataAndCastMakerToAave\n} from \"../../../../functions/InstaDapp/connectors/FConnectGelatoDataMakerToAave.sol\";\nimport {\n    _encodeGetDataAndCastMakerToMaker\n} from \"../../../../functions/InstaDapp/connectors/FConnectGelatoDataMakerToMaker.sol\";\nimport {\n    _encodeGetDataAndCastMakerToCompound\n} from \"../../../../functions/InstaDapp/connectors/FConnectGelatoDataMakerToCompound.sol\";\n\ncontract ConnectGelatoDataMakerToX is ConnectorInterface {\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable const-name-snakecase\n    string public constant override name = \"ConnectGelatoDataMakerToX-v1.0\";\n    uint256 internal immutable _id;\n    uint256 internal immutable _minDebt;\n    address internal immutable _connectGelatoDataMakerToAave;\n    address internal immutable _connectGelatoDataMakerToMaker;\n    address internal immutable _connectGelatoDataMakerToCompound;\n\n    constructor(\n        uint256 __id,\n        uint256 __minDebt,\n        address __connectGelatoDataMakerToAave,\n        address __connectGelatoDataMakerToMaker,\n        address __connectGelatoDataMakerToCompound\n    ) {\n        _id = __id;\n        _minDebt = __minDebt;\n        _connectGelatoDataMakerToAave = __connectGelatoDataMakerToAave;\n        _connectGelatoDataMakerToMaker = __connectGelatoDataMakerToMaker;\n        _connectGelatoDataMakerToCompound = __connectGelatoDataMakerToCompound;\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    // Overriding IGelatoAction's function (optional)\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow,\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        uint256 vaultAId = abi.decode(_actionData[4:36], (uint256));\n\n        if (vaultAId == 0)\n            return \"ConnectGelatoDataMakerToMaker: Vault A Id is not valid\";\n        if (!_isVaultOwner(vaultAId, _dsa))\n            return \"ConnectGelatoDataMakerToMaker: Vault A not owned by dsa\";\n        if (_getMakerVaultDebt(vaultAId) < _minDebt)\n            return \"ConnectGelatoDataMakerToMaker: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from e.g ETH-A to ETH-B\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _vaultAId Id of the unsafe vault of the client of Vault A Collateral.\n    /// @param _colToken The ETH-A collateral token.\n    /// @param _priceOracle The oracle used to track collateral price e.g. OSM or Chainlink.\n    /// @param _oraclePayload The payload for the oracle request.\n    /// @param _makerDestVaultId Only for Maker: e.g. ETH-B vault of the client.\n    /// @param _makerDestColType Only for Maker: colType of the new vault: e.g.ETH-B\n    function getDataAndCastFromMaker(\n        uint256 _vaultAId,\n        address _colToken,\n        address _priceOracle,\n        bytes memory _oraclePayload,\n        uint256 _makerDestVaultId,\n        string memory _makerDestColType\n    ) external payable {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataFromMaker(\n                _vaultAId,\n                _colToken,\n                DebtBridgeInputData({\n                    dsa: address(this),\n                    colAmt: _getMakerVaultCollateralBalance(_vaultAId),\n                    debtToken: DAI,\n                    debtAmt: _getRealisedDebt(_getMakerVaultDebt(_vaultAId)),\n                    priceOracle: _priceOracle,\n                    oraclePayload: _oraclePayload,\n                    makerDestVaultId: _makerDestVaultId,\n                    makerDestColType: _makerDestColType\n                })\n            );\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n\n        if (!success)\n            returndata.revertWithError(\"ConnectGelatoDataMakerToX._cast:\");\n    }\n\n    function _dataFromMaker(\n        uint256 _vaultAId,\n        address _colToken,\n        DebtBridgeInputData memory _data\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        PROTOCOL protocol = _getDebtBridgeRoute(_data);\n\n        require(\n            protocol != PROTOCOL.NONE,\n            \"ConnectGelatoDataMakerToX._dataFromMaker: PROTOCOL.NONE\"\n        );\n\n        targets = new address[](1);\n        datas = new bytes[](1);\n\n        if (protocol == PROTOCOL.AAVE) {\n            targets[0] = _connectGelatoDataMakerToAave;\n            datas[0] = _encodeGetDataAndCastMakerToAave(_vaultAId, _colToken);\n        } else if (protocol == PROTOCOL.MAKER) {\n            targets[0] = _connectGelatoDataMakerToMaker;\n            datas[0] = _encodeGetDataAndCastMakerToMaker(\n                _vaultAId,\n                _data.makerDestVaultId,\n                _data.makerDestColType,\n                _colToken\n            );\n        } else {\n            targets[0] = _connectGelatoDataMakerToCompound;\n            datas[0] = _encodeGetDataAndCastMakerToCompound(\n                _vaultAId,\n                _colToken\n            );\n        }\n    }\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectGelatoDataMakerToAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectGelatoDataMakerToAave\n} from \"../../../interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToAave.sol\";\n\nfunction _encodeGetDataAndCastMakerToAave(uint256 _vaultId, address _colToken)\n    pure\n    returns (bytes memory)\n{\n    return\n        abi.encodeWithSelector(\n            IConnectGelatoDataMakerToAave.getDataAndCastMakerToAave.selector,\n            _vaultId,\n            _colToken\n        );\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectGelatoDataMakerToMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectGelatoDataMakerToMaker\n} from \"../../../interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToMaker.sol\";\n\nfunction _encodeGetDataAndCastMakerToMaker(\n    uint256 _vaultAId,\n    uint256 _vaultBId,\n    string memory _colType,\n    address _colToken\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectGelatoDataMakerToMaker.getDataAndCastMakerToMaker.selector,\n            _vaultAId,\n            _vaultBId,\n            _colType,\n            _colToken\n        );\n}\n"
    },
    "contracts/functions/InstaDapp/connectors/FConnectGelatoDataMakerToCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IConnectGelatoDataMakerToCompound\n} from \"../../../interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToCompound.sol\";\n\nfunction _encodeGetDataAndCastMakerToCompound(\n    uint256 _vaultId,\n    address _colToken\n) pure returns (bytes memory) {\n    return\n        abi.encodeWithSelector(\n            IConnectGelatoDataMakerToCompound\n                .getDataAndCastMakerToCompound\n                .selector,\n            _vaultId,\n            _colToken\n        );\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectGelatoDataMakerToAave {\n    function getDataAndCastMakerToAave(uint256 _vaultId, address _colToken)\n        external\n        payable;\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToMaker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectGelatoDataMakerToMaker {\n    function getDataAndCastMakerToMaker(\n        uint256 _vaultAId,\n        uint256 _vaultBId,\n        string calldata _colType,\n        address _colToken\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/InstaDapp/connectors/IConnectGelatoDataMakerToCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IConnectGelatoDataMakerToCompound {\n    function getDataAndCastMakerToCompound(uint256 _vaultId, address _colToken)\n        external\n        payable;\n}\n"
    },
    "contracts/contracts/gelato/conditions/ConditionCanDoRefinance.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {\n    _getDebtBridgeRoute\n} from \"../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {PROTOCOL} from \"../../../constants/CDebtBridge.sol\";\nimport {GelatoBytes} from \"../../../lib/GelatoBytes.sol\";\nimport {DebtBridgeInputData} from \"../../../structs/SDebtBridge.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance\n} from \"../../../functions/dapps/FMaker.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getRealisedDebt\n} from \"../../../functions/gelato/FGelatoDebtBridge.sol\";\n\ncontract ConditionCanDoRefinance is GelatoConditionsStandard {\n    function getConditionData(\n        address _dsa,\n        uint256 _fromVaultId,\n        address _debtToken,\n        address _priceOracle,\n        bytes calldata _oraclePayload,\n        uint256 _makerDestVaultId,\n        string calldata _makerDestColType\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.canDoRefinance.selector,\n                _dsa,\n                _fromVaultId,\n                _debtToken,\n                _priceOracle,\n                _oraclePayload,\n                _makerDestVaultId,\n                _makerDestColType\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            address _dsa,\n            uint256 _fromVaultId,\n            address _debtToken,\n            address _priceOracle,\n            bytes memory _oraclePayload,\n            uint256 _makerDestVaultId,\n            string memory _makerDestColType\n        ) =\n            abi.decode(\n                _conditionData[4:],\n                (address, uint256, address, address, bytes, uint256, string)\n            );\n\n        return\n            canDoRefinance(\n                _dsa,\n                _fromVaultId,\n                _debtToken,\n                _priceOracle,\n                _oraclePayload,\n                _makerDestVaultId,\n                _makerDestColType\n            );\n    }\n\n    function canDoRefinance(\n        address _dsa,\n        uint256 _fromVaultId,\n        address _debtToken,\n        address _priceOracle,\n        bytes memory _oraclePayload,\n        uint256 _makerDestVaultId,\n        string memory _makerDestColType\n    ) public view returns (string memory) {\n        return\n            _getDebtBridgeRoute(\n                DebtBridgeInputData({\n                    dsa: _dsa,\n                    colAmt: _getMakerVaultCollateralBalance(_fromVaultId),\n                    debtToken: _debtToken,\n                    debtAmt: _getRealisedDebt(_getMakerVaultDebt(_fromVaultId)),\n                    priceOracle: _priceOracle,\n                    oraclePayload: _oraclePayload,\n                    makerDestVaultId: _makerDestVaultId,\n                    makerDestColType: _makerDestColType\n                })\n            ) != PROTOCOL.NONE\n                ? OK\n                : \"CannotDoRefinance\";\n    }\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\n\nimport \"./IGelatoCondition.sol\";\n\nabstract contract GelatoConditionsStandard is IGelatoCondition {\n    string internal constant OK = \"OK\";\n}\n"
    },
    "contracts/contracts/resolvers/MakerResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _getMakerRawVaultDebt,\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _vaultWillBeSafe,\n    _newVaultWillBeSafe,\n    _stringToBytes32\n} from \"../../functions/dapps/FMaker.sol\";\nimport {MCD_MANAGER} from \"../../constants/CMaker.sol\";\nimport {IMcdManager} from \"../../interfaces/dapps/Maker/IMcdManager.sol\";\nimport {IVat} from \"../../interfaces/dapps/Maker/IVat.sol\";\nimport {\n    _isDebtAmtDustExplicit\n} from \"../../functions/gelato/conditions/maker/FIsDebtAmtDust.sol\";\nimport {\n    _debtCeilingIsReachedExplicit\n} from \"../../functions/gelato/conditions/maker/FDebtCeilingIsReached.sol\";\n\ncontract MakerResolver {\n    /// @dev Return Debt in wad of the vault associated to the vaultId.\n    function getMakerVaultRawDebt(uint256 _vaultId)\n        public\n        view\n        returns (uint256)\n    {\n        return _getMakerRawVaultDebt(_vaultId);\n    }\n\n    function getMakerVaultDebt(uint256 _vaultId) public view returns (uint256) {\n        return _getMakerVaultDebt(_vaultId);\n    }\n\n    /// @dev Return Collateral in wad of the vault associated to the vaultId.\n    function getMakerVaultCollateralBalance(uint256 _vaultId)\n        public\n        view\n        returns (uint256)\n    {\n        return _getMakerVaultCollateralBalance(_vaultId);\n    }\n\n    function vaultWillBeSafe(\n        uint256 _vaultId,\n        uint256 _colAmt,\n        uint256 _daiDebtAmt\n    ) public view returns (bool) {\n        return _vaultWillBeSafe(_vaultId, _colAmt, _daiDebtAmt);\n    }\n\n    function newVaultWillBeSafe(\n        string memory _colType,\n        uint256 _colAmt,\n        uint256 _daiDebtAmt\n    ) public view returns (bool) {\n        return _newVaultWillBeSafe(_colType, _colAmt, _daiDebtAmt);\n    }\n\n    function getMaxDebtAmt(string memory _colType)\n        public\n        view\n        returns (uint256)\n    {\n        IMcdManager manager = IMcdManager(MCD_MANAGER);\n        IVat vat = IVat(manager.vat());\n        bytes32 ilk = _stringToBytes32(_colType);\n        (uint256 art, uint256 rate, , uint256 line, ) = vat.ilks(ilk);\n        return line - (art * rate);\n    }\n\n    function debtAmtIsDust(\n        uint256 _destVaultId,\n        string memory _colType,\n        uint256 _daiDebtAmt\n    ) public view returns (bool) {\n        return _isDebtAmtDustExplicit(_destVaultId, _colType, _daiDebtAmt);\n    }\n\n    function debtCeilingIsReached(\n        uint256 _destVaultId,\n        string memory _destColType,\n        uint256 _daiDebtAmt\n    ) public view returns (bool) {\n        return\n            _debtCeilingIsReachedExplicit(\n                _destVaultId,\n                _destColType,\n                _daiDebtAmt\n            );\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/maker/ConditionMakerToMakerLiquid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    _isDebtCeilingReached\n} from \"../../../../functions/gelato/conditions/maker/FDebtCeilingIsReached.sol\";\nimport {_getMakerVaultDebt} from \"../../../../functions/dapps/FMaker.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\n\ncontract ConditionMakerToMakerLiquid is GelatoConditionsStandard {\n    using GelatoBytes for bytes;\n\n    function getConditionData(\n        address _dsa,\n        uint256 _fromVaultId,\n        uint256 _destVaultId,\n        string calldata _destColType\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.isDebtCeilingReached.selector,\n                _dsa,\n                _fromVaultId,\n                _destVaultId,\n                _destColType\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            address _dsa,\n            uint256 _fromVaultId,\n            uint256 _destVaultId,\n            string memory _destColType\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\n\n        return\n            isDebtCeilingReached(\n                _dsa,\n                _fromVaultId,\n                _destVaultId,\n                _destColType\n            );\n    }\n\n    function isDebtCeilingReached(\n        address _dsa,\n        uint256 _fromVaultId,\n        uint256 _destVaultId,\n        string memory _destColType\n    ) public view returns (string memory) {\n        return\n            _isDebtCeilingReached(\n                _dsa,\n                _destVaultId,\n                _destColType,\n                _getRealisedDebt(_getMakerVaultDebt(_fromVaultId))\n            )\n                ? \"MakerDebtCeilingReached\"\n                : OK;\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/maker/ConditionMakerToMakerSafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    _destVaultWillBeSafe\n} from \"../../../../functions/gelato/conditions/maker/FDestVaultWillBeSafe.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance\n} from \"../../../../functions/dapps/FMaker.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\n\ncontract ConditionMakerToMakerSafe is GelatoConditionsStandard {\n    using GelatoBytes for bytes;\n\n    function getConditionData(\n        address _dsa,\n        uint256 _fromVaultId,\n        uint256 _destVaultId,\n        string calldata _destColType\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.destVaultWillBeSafe.selector,\n                _dsa,\n                _fromVaultId,\n                _destVaultId,\n                _destColType\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            address _dsa,\n            uint256 _fromVaultId,\n            uint256 _destVaultId,\n            string memory _destColType\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\n\n        return\n            destVaultWillBeSafe(_dsa, _fromVaultId, _destVaultId, _destColType);\n    }\n\n    function destVaultWillBeSafe(\n        address _dsa,\n        uint256 _fromVaultId,\n        uint256 _destVaultId,\n        string memory _destColType\n    ) public view returns (string memory) {\n        return\n            _destVaultWillBeSafe(\n                _dsa,\n                _destVaultId,\n                _destColType,\n                _getMakerVaultCollateralBalance(_fromVaultId),\n                _getRealisedDebt(_getMakerVaultDebt(_fromVaultId))\n            )\n                ? OK\n                : \"DestVaultWillNotBeSafe\";\n    }\n}\n"
    },
    "contracts/contracts/resolvers/CompoundResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _cTokenHasLiquidity\n} from \"../../functions/gelato/conditions/compound/FCompoundHasLiquidity.sol\";\nimport {\n    _compoundPositionWillBeSafe\n} from \"../../functions/gelato/conditions/compound/FCompoundPositionWillBeSafe.sol\";\n\ncontract CompoundResolver {\n    function compoundHasLiquidity(uint256 _amountToBorrow, address _debtToken)\n        public\n        view\n        returns (bool)\n    {\n        return _cTokenHasLiquidity(_debtToken, _amountToBorrow);\n    }\n\n    function compoundPositionWouldBeSafe(\n        address _dsa,\n        uint256 _colAmt,\n        address _debtToken,\n        uint256 _debtAmt\n    ) public view returns (bool) {\n        return _compoundPositionWillBeSafe(_dsa, _colAmt, _debtToken, _debtAmt);\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/compound/ConditionMakerToCompoundLiquidity.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    _cTokenHasLiquidity\n} from \"../../../../functions/gelato/conditions/compound/FCompoundHasLiquidity.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {_getMakerVaultDebt} from \"../../../../functions/dapps/FMaker.sol\";\n\ncontract ConditionMakerToCompoundLiquid is GelatoConditionsStandard {\n    function getConditionData(uint256 _fromVaultId)\n        public\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSelector(\n                this.cTokenHasLiquidity.selector,\n                _fromVaultId\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        uint256 _fromVaultId = abi.decode(_conditionData[4:], (uint256));\n\n        return cTokenHasLiquidity(_fromVaultId);\n    }\n\n    function cTokenHasLiquidity(uint256 _fromVaultId)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            _cTokenHasLiquidity(\n                DAI,\n                _getRealisedDebt(_getMakerVaultDebt(_fromVaultId))\n            )\n                ? OK\n                : \"CompoundHasNotEnoughLiquidity\";\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/compound/ConditionMakerToCompoundSafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {\n    _compoundPositionWillBeSafe\n} from \"../../../../functions/gelato/conditions/compound/FCompoundPositionWillBeSafe.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance\n} from \"../../../../functions/dapps/FMaker.sol\";\n\ncontract ConditionMakerToCompoundSafe is GelatoConditionsStandard {\n    function getConditionData(address _dsa, uint256 _fromVaultId)\n        public\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return\n            abi.encodeWithSelector(\n                this.compoundPositionWillBeSafe.selector,\n                _dsa,\n                _fromVaultId\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (address _dsa, uint256 _fromVaultId) =\n            abi.decode(_conditionData[4:], (address, uint256));\n\n        return compoundPositionWillBeSafe(_dsa, _fromVaultId);\n    }\n\n    function compoundPositionWillBeSafe(address _dsa, uint256 _fromVaultId)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            _compoundPositionWillBeSafe(\n                _dsa,\n                _getMakerVaultCollateralBalance(_fromVaultId),\n                DAI,\n                _getRealisedDebt(_getMakerVaultDebt(_fromVaultId))\n            )\n                ? OK\n                : \"CompoundPositionsWillNotBeSafe\";\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/maker/ConditionMakerVaultUnsafeOSM.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {\n    _isVaultUnsafeOSM\n} from \"../../../../functions/gelato/conditions/maker/FMakerVaultUnsafeOSM.sol\";\n\n/// @title ConditionMakerVaultUnsafe\n/// @notice Condition tracking Maker vault collateralization safety requirements.\n/// @author Gelato Team\ncontract ConditionMakerVaultUnsafeOSM is GelatoConditionsStandard {\n    /// @notice Standard GelatoCore system function\n    /// @dev A standard interface for GelatoCore to read Conditions\n    /// @param _conditionData The data you get from `getConditionData()`\n    /// @return OK if the Condition is there, else some error message.\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            uint256 _vaultID,\n            address _priceOracle,\n            bytes memory _oraclePayload,\n            uint256 _minColRatio\n        ) = abi.decode(_conditionData[4:], (uint256, address, bytes, uint256));\n\n        return\n            isVaultUnsafeOSM(\n                _vaultID,\n                _priceOracle,\n                _oraclePayload,\n                _minColRatio\n            );\n    }\n\n    /// @notice Specific implementation of this Condition's ok function\n    /// @dev The price oracle must return (bytes32, bool).\n    /// @param _vaultID The id of the Maker vault\n    /// @param _priceOracle The price oracle contract to supply the collateral price\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\n    ///  method e.g. the selector for MakerOracle's read fn.\n    /// @param _minColRatio The minimum collateral ratio measured in the price\n    /// of the collateral as specified by the _priceOracle.\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\n    function isVaultUnsafeOSM(\n        uint256 _vaultID,\n        address _priceOracle,\n        bytes memory _oraclePayload,\n        uint256 _minColRatio\n    ) public view virtual returns (string memory) {\n        return\n            _isVaultUnsafeOSM(\n                _vaultID,\n                _priceOracle,\n                _oraclePayload,\n                _minColRatio\n            )\n                ? OK\n                : \"MakerVaultNotUnsafe\";\n    }\n\n    /// @notice Convenience function for off-chain _conditionData encoding\n    /// @dev Use the return for your Task's Condition.data field off-chain.\n    /// @return The encoded payload for your Task's Condition.data field.\n    function getConditionData(\n        uint256 _vaultId,\n        address _priceOracle,\n        bytes calldata _oraclePayload,\n        uint256 _minColRatio\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.isVaultUnsafeOSM.selector,\n                _vaultId,\n                _priceOracle,\n                _oraclePayload,\n                _minColRatio\n            );\n    }\n}\n"
    },
    "contracts/functions/gelato/conditions/maker/FMakerVaultUnsafeOSM.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {wmul, wdiv} from \"../../../../vendor/DSMath.sol\";\nimport {\n    IInstaMakerResolver\n} from \"../../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {INSTA_MAKER_RESOLVER} from \"../../../../constants/CInstaDapp.sol\";\n\nfunction _isVaultUnsafeOSM(\n    uint256 _vaultId,\n    address _priceOracle,\n    bytes memory _oraclePayload,\n    uint256 _minColRatio\n) view returns (bool) {\n    (bool success, bytes memory returndata) =\n        _priceOracle.staticcall(_oraclePayload);\n\n    if (!success) {\n        GelatoBytes.revertWithError(\n            returndata,\n            \"FMakerVaultUnsafeOSM._isVaultUnsafeOSM:oracle:\"\n        );\n    }\n\n    (bytes32 colPrice, bool hasNxt) = abi.decode(returndata, (bytes32, bool));\n\n    require(hasNxt, \"FMakerVaultUnsafeOSM._isVaultUnsafeOSM: !hasNxt\");\n\n    IInstaMakerResolver.VaultData memory vault =\n        IInstaMakerResolver(INSTA_MAKER_RESOLVER).getVaultById(_vaultId);\n\n    return\n        wdiv(wmul(vault.collateral, uint256(colPrice)), vault.debt) <\n        _minColRatio;\n}\n"
    },
    "contracts/interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IInstaMakerResolver {\n    struct VaultData {\n        uint256 id;\n        address owner;\n        string colType;\n        uint256 collateral;\n        uint256 art;\n        uint256 debt;\n        uint256 liquidatedCol;\n        uint256 borrowRate;\n        uint256 colPrice;\n        uint256 liquidationRatio;\n        address vaultAddress;\n    }\n\n    function getVaultById(uint256 id) external view returns (VaultData memory);\n}\n"
    },
    "contracts/functions/InstaDapp/FInstaDapp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {MemoryInterface} from \"../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {INSTA_MEMORY} from \"../../constants/CInstaDapp.sol\";\n\nfunction _setUint(uint256 setId, uint256 val) {\n    if (setId != 0) MemoryInterface(INSTA_MEMORY).setUint(setId, val);\n}\n\nfunction _getUint(uint256 getId, uint256 val) returns (uint256 returnVal) {\n    returnVal = getId == 0 ? val : MemoryInterface(INSTA_MEMORY).getUint(getId);\n}\n"
    },
    "contracts/contracts/connectors/debt_bridge/ConnectGelatoDebtBridgeFee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ConnectorInterface} from \"../../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {IInstaMemory} from \"../../../interfaces/InstaDapp/IInstaMemory.sol\";\nimport {INSTA_MEMORY} from \"../../../constants/CInstaDapp.sol\";\nimport {wmul} from \"../../../vendor/DSMath.sol\";\n\ncontract ConnectGelatoDebtBridgeFee is ConnectorInterface {\n    // solhint-disable const-name-snakecase\n    string public constant override name = \"ConnectGelatoDebtBridgeFee-v1.0\";\n    uint256 internal immutable _id;\n\n    constructor(uint256 __id) {\n        _id = __id;\n    }\n\n    /// @notice Function to compute Fee and borrow amount\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _debt the amount of debt at the beginning\n    /// @param _txFee  fast transaction fee of Gelato.\n    /// @param _instaFeeFactor  instadapp fee.\n    /// @param _getId  the amount storing Id in instaMemory.\n    /// @param _setId  id to store total amount (e.g. debt or col to draw)\n    /// @param _setIdInstaFee  id to store instaFee\n    function calculateFee(\n        uint256 _debt,\n        uint256 _txFee,\n        uint256 _instaFeeFactor,\n        uint256 _getId,\n        uint256 _setId,\n        uint256 _setIdInstaFee\n    ) external payable {\n        _debt = _getUint(_getId, _debt);\n\n        uint256 instaFee = wmul(_debt, _instaFeeFactor);\n\n        _setUint(_setId, _debt + _txFee + instaFee); // Total amount to borrow.\n        _setUint(_setIdInstaFee, instaFee);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id);\n    }\n\n    /// @dev Get Uint value from InstaMemory Contract.\n    function _getUint(uint256 _getId, uint256 _val)\n        internal\n        returns (uint256 returnVal)\n    {\n        returnVal = _getId == 0\n            ? _val\n            : IInstaMemory(INSTA_MEMORY).getUint(_getId);\n    }\n\n    /// @dev Set Uint value in InstaMemory Contract.\n    function _setUint(uint256 _setId, uint256 _val) internal {\n        if (_setId != 0) IInstaMemory(INSTA_MEMORY).setUint(_setId, _val);\n    }\n}\n"
    },
    "contracts/interfaces/InstaDapp/IInstaMemory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IInstaMemory {\n    function getUint(uint256 _id) external returns (uint256 _num);\n\n    function setUint(uint256 _id, uint256 _val) external;\n}\n"
    },
    "contracts/functions/gelato/conditions/maker/FMakerVaultUnsafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {wmul, wdiv} from \"../../../../vendor/DSMath.sol\";\nimport {\n    IInstaMakerResolver\n} from \"../../../../interfaces/InstaDapp/resolvers/IInstaMakerResolver.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {INSTA_MAKER_RESOLVER} from \"../../../../constants/CInstaDapp.sol\";\n\nfunction _isVaultUnsafe(\n    uint256 _vaultId,\n    address _priceOracle,\n    bytes memory _oraclePayload,\n    uint256 _minColRatio\n) view returns (bool) {\n    (bool success, bytes memory returndata) =\n        _priceOracle.staticcall(_oraclePayload);\n\n    if (!success) {\n        GelatoBytes.revertWithError(\n            returndata,\n            \"ConditionMakerVaultUnsafe.isVaultUnsafe:oracle:\"\n        );\n    }\n\n    uint256 colPrice = abi.decode(returndata, (uint256));\n\n    IInstaMakerResolver.VaultData memory vault =\n        IInstaMakerResolver(INSTA_MAKER_RESOLVER).getVaultById(_vaultId);\n\n    uint256 colRatio = wdiv(wmul(vault.collateral, colPrice), vault.debt);\n\n    return colRatio < _minColRatio;\n}\n"
    },
    "contracts/contracts/resolvers/PriceOracleResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {Ownable} from \"../../vendor/openzeppelin/contracts/access/Ownable.sol\";\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\n\n/// @title PriceOracleResolver\n/// @notice Contract with convenience methods to retrieve oracle addresses or to mock test.\n/// @dev Can be used to:\n///  - Query oracle address for Gelato Condition payloads on frontend\n///  - Test Conditions by using `getMockPrice(address _test)` as `oraclePayload`\ncontract PriceOracleResolver is Ownable {\n    using GelatoBytes for bytes;\n\n    mapping(string => address) public oracle;\n    mapping(string => bytes) public oraclePayload;\n    mapping(address => uint256) public mockPrice;\n\n    /// @notice Adds a new Oracle address\n    /// @dev Only owner can call this, but existing oracle entries are immutable\n    /// @param _oracle The descriptor of the oracle e.g. ETH/USD-Maker-v1\n    /// @param _oracleAddress The address of the oracle contract\n    /// @param _oraclePayload The payload with function selector for the oracle request.\n    function addOracle(\n        string memory _oracle,\n        address _oracleAddress,\n        bytes calldata _oraclePayload\n    ) external onlyOwner {\n        require(\n            oracle[_oracle] == address(0),\n            \"PriceOracleResolver.addOracle: set\"\n        );\n        oracle[_oracle] = _oracleAddress;\n        oraclePayload[_oracle] = _oraclePayload;\n    }\n\n    /// @notice Function that allows easy oracle data testing in production.\n    /// @dev Your mock prices cannot be overriden by someone else.\n    /// @param _mockPrice The mock data you want to test against.\n    function setMockPrice(uint256 _mockPrice) public {\n        mockPrice[msg.sender] = _mockPrice;\n    }\n\n    /// @notice Use with setMockPrice for easy testing in production.\n    /// @dev Encode oracle=PriceOracleResolver and oraclePayload=getMockPrice(tester)\n    ///  to test your Conditions or Actions that make dynamic calls to price oracles.\n    /// @param _tester The msg.sender during setMockPrice.\n    /// @return The tester's mockPrice.\n    function getMockPrice(address _tester) external view returns (uint256) {\n        return mockPrice[_tester];\n    }\n\n    /// @notice A generelized getter for a price supplied by an oracle contract.\n    /// @dev The oracle returndata must be formatted as a single uint256.\n    /// @param _oracle The descriptor of our oracle e.g. ETH/USD-Maker-v1\n    /// @return The uint256 oracle price\n    function getPrice(string memory _oracle) external view returns (uint256) {\n        address oracleAddr = oracle[_oracle];\n        if (oracleAddr == address(0))\n            revert(\"PriceOracleResolver.getPrice: no oracle\");\n        (bool success, bytes memory returndata) =\n            oracleAddr.staticcall(oraclePayload[_oracle]);\n        if (!success)\n            returndata.revertWithError(\"PriceOracleResolver.getPrice:\");\n        return abi.decode(returndata, (uint256));\n    }\n}\n"
    },
    "contracts/contracts/gelato/OracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {Ownable} from \"../../vendor/openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeMath} from \"../../vendor/openzeppelin/contracts/math/SafeMath.sol\";\n\ninterface IGasPriceOracle {\n    function latestAnswer() external view returns (int256);\n\n    function decimals() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n}\n\n// solhint-disable max-states-count\ncontract OracleAggregator is Ownable {\n    using SafeMath for uint256;\n    // solhint-disable var-name-mixedcase\n    address private _ETH_ADDRESS;\n    // solhint-disable var-name-mixedcase\n    address private _USD_ADDRESS;\n\n    mapping(address => mapping(address => address)) private _tokenPairAddress;\n    mapping(address => uint256) private _nrOfDecimalsUSD;\n\n    // solhint-disable function-max-lines\n    constructor() {\n        _nrOfDecimalsUSD[0x7354C81fbCb229187480c4f497F945C6A312d5C3] = 8; // USD\n        _nrOfDecimalsUSD[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 6; // USDT\n        _nrOfDecimalsUSD[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 6; // USDC\n        _nrOfDecimalsUSD[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 18; // DAI\n        _nrOfDecimalsUSD[0x4Fabb145d64652a948d72533023f6E7A623C7C53] = 18; // BUSD\n        _nrOfDecimalsUSD[0x57Ab1ec28D129707052df4dF418D58a2D46d5f51] = 18; // SUSD\n        _nrOfDecimalsUSD[0x0000000000085d4780B73119b644AE5ecd22b376] = 18; // TUSD\n\n        _ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n        _USD_ADDRESS = 0x7354C81fbCb229187480c4f497F945C6A312d5C3; // Random address\n\n        _tokenPairAddress[0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9][\n            _ETH_ADDRESS\n        ] = 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012; // AAVE/ETH\n        _tokenPairAddress[0xADE00C28244d5CE17D72E40330B1c318cD12B7c3][\n            _USD_ADDRESS\n        ] = 0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10; // ADX/USD\n\n        _tokenPairAddress[0x0D8775F648430679A709E98d2b0Cb6250d2887EF][\n            _ETH_ADDRESS\n        ] = 0x0d16d4528239e9ee52fa531af613AcdB23D88c94; // BAT/ETH\n        _tokenPairAddress[0xB8c77482e45F1F44dE1745F52C74426C631bDD52][\n            _USD_ADDRESS\n        ] = 0x14e613AC84a31f709eadbdF89C6CC390fDc9540A; // BNB/USD\n        _tokenPairAddress[0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C][\n            _ETH_ADDRESS\n        ] = 0xCf61d1841B178fe82C8895fe60c2EDDa08314416; // BNT/ETH\n        _tokenPairAddress[0x56d811088235F11C8920698a204A5010a788f4b3][\n            _ETH_ADDRESS\n        ] = 0x8f7C7181Ed1a2BA41cfC3f5d064eF91b67daef66; // BZRX/ETH\n\n        _tokenPairAddress[0xc00e94Cb662C3520282E6f5717214004A7f26888][\n            _ETH_ADDRESS\n        ] = 0x1B39Ee86Ec5979ba5C322b826B3ECb8C79991699; // COMP/ETH\n        _tokenPairAddress[0xc00e94Cb662C3520282E6f5717214004A7f26888][\n            _USD_ADDRESS\n        ] = 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5; // COMP/USD\n        _tokenPairAddress[0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b][\n            _ETH_ADDRESS\n        ] = 0xcA696a9Eb93b81ADFE6435759A29aB4cf2991A96; // CRO/ETH\n\n        _tokenPairAddress[0xEd91879919B71bB6905f23af0A68d231EcF87b14][\n            _ETH_ADDRESS\n        ] = 0xD010e899f7ab723AC93f825cDC5Aa057669557c2; // DMG/ETH\n\n        _tokenPairAddress[0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c][\n            _ETH_ADDRESS\n        ] = 0x24D9aB51950F3d62E9144fdC2f3135DAA6Ce8D1B; // ENJ/ETH\n        _tokenPairAddress[_ETH_ADDRESS][\n            _USD_ADDRESS\n        ] = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // ETH/USD\n\n        _tokenPairAddress[0xdd974D5C2e2928deA5F71b9825b8b646686BD200][\n            _ETH_ADDRESS\n        ] = 0x656c0544eF4C98A6a98491833A89204Abb045d6b; // KNC/ETH\n        _tokenPairAddress[0xdd974D5C2e2928deA5F71b9825b8b646686BD200][\n            _USD_ADDRESS\n        ] = 0xf8fF43E991A81e6eC886a3D281A2C6cC19aE70Fc; // KNC/USD\n\n        _tokenPairAddress[0x514910771AF9Ca656af840dff83E8264EcF986CA][\n            _USD_ADDRESS\n        ] = 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c; // LINK/USD\n        _tokenPairAddress[0x514910771AF9Ca656af840dff83E8264EcF986CA][\n            _ETH_ADDRESS\n        ] = 0xDC530D9457755926550b59e8ECcdaE7624181557; // LINK/ETH\n        _tokenPairAddress[0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD][\n            _ETH_ADDRESS\n        ] = 0x160AC928A16C93eD4895C2De6f81ECcE9a7eB7b4; // LRC/ETH\n        _tokenPairAddress[0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD][\n            _USD_ADDRESS\n        ] = 0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10; // LRC/USD\n\n        _tokenPairAddress[0x0F5D2fB29fb7d3CFeE444a200298f468908cC942][\n            _ETH_ADDRESS\n        ] = 0x82A44D92D6c329826dc557c5E1Be6ebeC5D5FeB9; // MANA/ETH\n        _tokenPairAddress[0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2][\n            _ETH_ADDRESS\n        ] = 0x24551a8Fb2A7211A25a17B1481f043A8a8adC7f2; // MKR/ETH\n\n        _tokenPairAddress[0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671][\n            _ETH_ADDRESS\n        ] = 0x9cB2A01A7E64992d32A34db7cEea4c919C391f6A; // NMR/ETH\n\n        _tokenPairAddress[0x408e41876cCCDC0F92210600ef50372656052a38][\n            _ETH_ADDRESS\n        ] = 0x3147D7203354Dc06D9fd350c7a2437bcA92387a4; // REN/ETH\n        _tokenPairAddress[0x408e41876cCCDC0F92210600ef50372656052a38][\n            _USD_ADDRESS\n        ] = 0x0f59666EDE214281e956cb3b2D0d69415AfF4A01; // REN/USD\n        _tokenPairAddress[0x221657776846890989a759BA2973e427DfF5C9bB][\n            _ETH_ADDRESS\n        ] = 0xD4CE430C3b67b3E2F7026D86E7128588629e2455; // REP/ETH\n\n        _tokenPairAddress[0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F][\n            _ETH_ADDRESS\n        ] = 0x79291A9d692Df95334B1a0B3B4AE6bC606782f8c; // SNX/ETH\n        _tokenPairAddress[0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F][\n            _USD_ADDRESS\n        ] = 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699; // SNX/USD\n        _tokenPairAddress[0x8CE9137d39326AD0cD6491fb5CC0CbA0e089b6A9][\n            _USD_ADDRESS\n        ] = 0xFb0CfD6c19e25DB4a08D8a204a387cEa48Cc138f; // SXP/USD\n\n        _tokenPairAddress[0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984][\n            _ETH_ADDRESS\n        ] = 0xD6aA3D25116d8dA79Ea0246c4826EB951872e02e; // UNI/ETH\n        _tokenPairAddress[_USD_ADDRESS][\n            _ETH_ADDRESS\n        ] = 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4; // USDC/ETH\n\n        _tokenPairAddress[0xa982B2e19e90b2D9F7948e9C1b65D119F1CE88D6][\n            _ETH_ADDRESS\n        ] = 0xcEBD2026d3C99F2a7CE028acf372C154aB4638a9; // WOM/ETH\n\n        _tokenPairAddress[0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e][\n            _ETH_ADDRESS\n        ] = 0x7c5d4F8345e66f68099581Db340cd65B078C41f4; // YFI/ETH\n\n        _tokenPairAddress[0xE41d2489571d322189246DaFA5ebDe1F4699F498][\n            _ETH_ADDRESS\n        ] = 0x2Da4983a622a8498bb1a21FaE9D8F6C664939962; // ZRX/ETH\n    }\n\n    function addToken(\n        address tokenAddressA,\n        address tokenAddressB,\n        address __tokenPairAddress\n    ) public onlyOwner {\n        _tokenPairAddress[tokenAddressA][tokenAddressB] = __tokenPairAddress;\n    }\n\n    // solhint-disable function-max-lines\n    // solhint-disable code-complexity\n    /// @dev Get expected return amount for tokenA / tokenB\n    function getExpectedReturnAmount(\n        uint256 amount,\n        address tokenAddressA,\n        address tokenAddressB\n    ) public view returns (uint256 returnAmount, uint256 decimals) {\n        require(amount > 0, \"OracleAggregator: Amount is Zero\");\n        require(\n            tokenAddressA != address(0),\n            \"OracleAggregator: tokenAddressA is Zero\"\n        );\n        require(\n            tokenAddressB != address(0),\n            \"OracleAggregator: tokenAddressB is Zero\"\n        );\n\n        uint256 nrOfDecimalsIn;\n        if (tokenAddressA != _ETH_ADDRESS) {\n            // Don't work for USD as tokenAddressA\n            try IERC20(tokenAddressA).decimals() returns (\n                uint8 _inputDecimals\n            ) {\n                nrOfDecimalsIn = uint256(_inputDecimals);\n            } catch {\n                revert(\"OracleAggregator: ERC20.decimals() revert\");\n            }\n        } else {\n            nrOfDecimalsIn = 18;\n        }\n\n        address stableCoinAddress =\n            _nrOfDecimalsUSD[tokenAddressB] > 0 ? tokenAddressB : address(0);\n\n        (tokenAddressA, tokenAddressB) = _convertUSD(\n            tokenAddressA,\n            tokenAddressB\n        );\n\n        // when token_b is ETH or USD\n        if (tokenAddressB == _ETH_ADDRESS || tokenAddressB == _USD_ADDRESS) {\n            // oracle of token_a / token_b exists\n            // e.g. calculating KNC/ETH\n            // KNC/ETH oracle available\n            if (_tokenPairAddress[tokenAddressA][tokenAddressB] != address(0)) {\n                (uint256 returnRateA, uint256 nrOfDecimals) =\n                    _getRate(tokenAddressA, tokenAddressB);\n\n                returnAmount = stableCoinAddress != address(0)\n                    ? _matchStableCoinDecimal(\n                        stableCoinAddress,\n                        amount,\n                        nrOfDecimals,\n                        0,\n                        returnRateA,\n                        1\n                    )\n                    : amount.mul(returnRateA);\n\n                return (returnAmount.div(10**nrOfDecimalsIn), nrOfDecimalsIn);\n            } else {\n                // oracle of token_a / token_b does not exist\n                // e.g. calculating UNI/USD\n                // UNI/ETH and USD/ETH oracles available\n                (address pairA, address pairB) =\n                    _checkAvailablePair(tokenAddressA, tokenAddressB);\n                if (pairA == address(0) && pairB == address(0)) return (0, 0);\n\n                (uint256 returnRateA, ) = _getRate(tokenAddressA, pairA);\n\n                (uint256 returnRateB, uint256 nrOfDecimals) =\n                    _getRate(tokenAddressB, pairB);\n\n                nrOfDecimals = stableCoinAddress != address(0)\n                    ? _nrOfDecimalsUSD[stableCoinAddress]\n                    : nrOfDecimals;\n\n                returnAmount = amount\n                    .mul(returnRateA.mul(10**nrOfDecimals))\n                    .div(returnRateB);\n                if (tokenAddressB != _ETH_ADDRESS) {\n                    return (\n                        returnAmount.div(10**nrOfDecimalsIn),\n                        nrOfDecimalsIn\n                    );\n                } else {\n                    return (\n                        returnAmount.div(10**_nrOfDecimalsUSD[_USD_ADDRESS]),\n                        nrOfDecimalsIn\n                    );\n                }\n            }\n        } else {\n            // when token_b is not ETH or USD\n            (address pairA, address pairB) =\n                _checkAvailablePair(tokenAddressA, tokenAddressB);\n\n            if (pairA == address(0) && pairB == address(0)) return (0, 0);\n            // oracle of token_a/ETH, token_b/ETH || token_a/USD, token_b/USD exists\n            // e.g. calculating KNC/UNI where\n            // KNC/ETH and UNI/ETH oracles available\n            if (pairA == pairB) {\n                (uint256 returnRateA, uint256 nrOfDecimals) =\n                    _getRate(tokenAddressA, pairA);\n\n                (uint256 returnRateB, ) = _getRate(tokenAddressB, pairB);\n\n                returnAmount = amount\n                    .mul(returnRateA.mul(10**nrOfDecimals))\n                    .div(returnRateB);\n                if (pairA == _ETH_ADDRESS) {\n                    return (\n                        returnAmount.div(10**nrOfDecimalsIn),\n                        nrOfDecimalsIn\n                    );\n                } else {\n                    return (\n                        returnAmount.div(10**_nrOfDecimalsUSD[_USD_ADDRESS]),\n                        nrOfDecimalsIn\n                    );\n                }\n            } else if (pairA == _ETH_ADDRESS && pairB == _USD_ADDRESS) {\n                // oracle of token_a/ETH and token_b/USD exists\n                // e.g. calculating UNI/SXP where\n                // UNI/ETH and SXP/USD oracles available\n                {\n                    (uint256 returnRateA, ) = _getRate(tokenAddressA, pairA);\n                    (uint256 returnRate_ETHUSD, ) =\n                        _getRate(_ETH_ADDRESS, _USD_ADDRESS);\n                    (uint256 returnRateB, ) = _getRate(tokenAddressB, pairB);\n\n                    returnAmount = amount\n                        .mul(returnRateA.mul(returnRate_ETHUSD))\n                        .div(returnRateB);\n                }\n                return (returnAmount.div(10**nrOfDecimalsIn), nrOfDecimalsIn);\n            } else if (pairA == _USD_ADDRESS && pairB == _ETH_ADDRESS) {\n                // oracle of token_a/USD and token_b/ETH exists\n                // e.g. calculating SXP/UNI where\n                // SXP/USD and UNI/ETH oracles available\n                uint256 numerator;\n                {\n                    (uint256 returnRateA, uint256 nrOfDecimals) =\n                        _getRate(tokenAddressA, pairA);\n\n                    (uint256 returnRate_USDETH, uint256 nrOfDecimals_USDETH) =\n                        _getRate(_USD_ADDRESS, _ETH_ADDRESS);\n\n                    numerator = returnRate_USDETH\n                        .mul(10**(nrOfDecimals_USDETH.sub(nrOfDecimals)))\n                        .mul(returnRateA)\n                        .div(10**nrOfDecimals_USDETH);\n                }\n                (uint256 returnRateB, ) = _getRate(tokenAddressB, pairB);\n                returnAmount = amount.mul(numerator).div(returnRateB);\n                return (returnAmount, nrOfDecimalsIn);\n            }\n        }\n    }\n\n    /// @dev check the available oracles for token a & b\n    /// and choose which oracles to use\n    function _checkAvailablePair(address tokenAddressA, address tokenAddressB)\n        private\n        view\n        returns (address, address)\n    {\n        if (\n            _tokenPairAddress[tokenAddressA][_USD_ADDRESS] != address(0) &&\n            _tokenPairAddress[tokenAddressB][_USD_ADDRESS] != address(0)\n        ) {\n            return (_USD_ADDRESS, _USD_ADDRESS);\n        } else if (\n            _tokenPairAddress[tokenAddressA][_ETH_ADDRESS] != address(0) &&\n            _tokenPairAddress[tokenAddressB][_ETH_ADDRESS] != address(0)\n        ) {\n            return (_ETH_ADDRESS, _ETH_ADDRESS);\n        } else if (\n            _tokenPairAddress[tokenAddressA][_ETH_ADDRESS] != address(0) &&\n            _tokenPairAddress[tokenAddressB][_USD_ADDRESS] != address(0)\n        ) {\n            return (_ETH_ADDRESS, _USD_ADDRESS);\n        } else if (\n            _tokenPairAddress[tokenAddressA][_USD_ADDRESS] != address(0) &&\n            _tokenPairAddress[tokenAddressB][_ETH_ADDRESS] != address(0)\n        ) {\n            return (_USD_ADDRESS, _ETH_ADDRESS);\n        } else {\n            return (address(0), address(0));\n        }\n    }\n\n    function _getRate(address tokenAddressA, address tokenAddressB)\n        private\n        view\n        returns (uint256 tokenPrice, uint256 nrOfDecimals)\n    {\n        if (tokenAddressA == tokenAddressB) {\n            return (1, 0);\n        } else {\n            IGasPriceOracle priceFeed =\n                IGasPriceOracle(\n                    _tokenPairAddress[tokenAddressA][tokenAddressB]\n                );\n            tokenPrice = uint256(priceFeed.latestAnswer());\n            nrOfDecimals = priceFeed.decimals();\n        }\n    }\n\n    /// @dev converting all usd pegged stablecoins to single USD address\n    function _convertUSD(address tokenAddressA, address tokenAddressB)\n        private\n        view\n        returns (address, address)\n    {\n        if (\n            _nrOfDecimalsUSD[tokenAddressA] > 0 &&\n            _nrOfDecimalsUSD[tokenAddressB] > 0\n        ) {\n            return (_USD_ADDRESS, _USD_ADDRESS);\n        } else if (_nrOfDecimalsUSD[tokenAddressA] > 0) {\n            return (_USD_ADDRESS, tokenAddressB);\n        } else if (_nrOfDecimalsUSD[tokenAddressB] > 0) {\n            return (tokenAddressA, _USD_ADDRESS);\n        } else {\n            return (tokenAddressA, tokenAddressB);\n        }\n    }\n\n    /// @dev modify nrOfDecimlas and amount to follow stableCoin's nrOfDecimals\n    function _matchStableCoinDecimal(\n        address stableCoinAddress,\n        uint256 amount,\n        uint256 nrOfDecimals,\n        uint256 padding,\n        uint256 returnRateA,\n        uint256 returnRateB\n    ) private view returns (uint256 returnAmount) {\n        uint256 div =\n            _nrOfDecimalsUSD[stableCoinAddress] > nrOfDecimals\n                ? 10**(_nrOfDecimalsUSD[stableCoinAddress] - nrOfDecimals)\n                : 10**(nrOfDecimals - _nrOfDecimalsUSD[stableCoinAddress]);\n        returnAmount = _nrOfDecimalsUSD[stableCoinAddress] > nrOfDecimals\n            ? amount.mul(returnRateA.mul(10**padding)).div(returnRateB).mul(div)\n            : amount.mul(returnRateA.mul(10**padding)).div(returnRateB).div(\n                div\n            );\n    }\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/contracts/gelato/conditions/maker/ConditionMakerVaultUnsafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    _isVaultUnsafe\n} from \"../../../../functions/gelato/conditions/maker/FMakerVaultUnsafe.sol\";\n\n/// @title ConditionMakerVaultUnsafe\n/// @notice Condition tracking Maker vault collateralization safety requirements.\n/// @author Gelato Team\ncontract ConditionMakerVaultUnsafe is GelatoConditionsStandard {\n    using GelatoBytes for bytes;\n\n    /// @notice Convenience function for off-chain _conditionData encoding\n    /// @dev Use the return for your Task's Condition.data field off-chain.\n    /// @return The encoded payload for your Task's Condition.data field.\n    function getConditionData(\n        uint256 _vaultId,\n        address _priceOracle,\n        bytes calldata _oraclePayload,\n        uint256 _minColRatio\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.isVaultUnsafe.selector,\n                _vaultId,\n                _priceOracle,\n                _oraclePayload,\n                _minColRatio\n            );\n    }\n\n    /// @notice Standard GelatoCore system function\n    /// @dev A standard interface for GelatoCore to read Conditions\n    /// @param _conditionData The data you get from `getConditionData()`\n    /// @return OK if the Condition is there, else some error message.\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            uint256 _vaultID,\n            address _priceOracle,\n            bytes memory _oraclePayload,\n            uint256 _minColRatio\n        ) = abi.decode(_conditionData[4:], (uint256, address, bytes, uint256));\n\n        return\n            isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio);\n    }\n\n    /// @notice Specific implementation of this Condition's ok function\n    /// @dev The price oracle must return a uint256 WAD (10**18) value.\n    /// @param _vaultID The id of the Maker vault\n    /// @param _priceOracle The price oracle contract to supply the collateral price\n    ///  e.g. Maker's ETH/USD oracle for ETH collateral pricing.\n    /// @param _oraclePayload The data for making the staticcall to the oracle's read\n    ///  method e.g. the selector for MakerOracle's read fn.\n    /// @param _minColRatio The minimum collateral ratio measured in the price\n    /// of the collateral as specified by the _priceOracle.\n    /// @return OK if the Maker Vault is unsafe, otherwise some error message.\n    function isVaultUnsafe(\n        uint256 _vaultID,\n        address _priceOracle,\n        bytes memory _oraclePayload,\n        uint256 _minColRatio\n    ) public view virtual returns (string memory) {\n        return\n            _isVaultUnsafe(_vaultID, _priceOracle, _oraclePayload, _minColRatio)\n                ? OK\n                : \"MakerVaultNotUnsafe\";\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/maker/ConditionDebtAmtIsDust.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    _isDebtAmtDust\n} from \"../../../../functions/gelato/conditions/maker/FIsDebtAmtDust.sol\";\nimport {\n    _getMakerVaultDebt,\n    _isVaultOwner\n} from \"../../../../functions/dapps/FMaker.sol\";\n\ncontract ConditionDebtAmtIsDust is GelatoConditionsStandard {\n    using GelatoBytes for bytes;\n\n    function getConditionData(\n        address _dsa,\n        uint256 _fromVaultId,\n        uint256 _destVaultId,\n        string calldata _destColType\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.isDebtAmtDust.selector,\n                _dsa,\n                _fromVaultId,\n                _destVaultId,\n                _destColType\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            address _dsa,\n            uint256 _fromVaultId,\n            uint256 _destVaultId,\n            string memory _destColType\n        ) = abi.decode(_conditionData[4:], (address, uint256, uint256, string));\n\n        return isDebtAmtDust(_dsa, _fromVaultId, _destVaultId, _destColType);\n    }\n\n    function isDebtAmtDust(\n        address _dsa,\n        uint256 _fromVaultId,\n        uint256 _destVaultId,\n        string memory _destColType\n    ) public view returns (string memory) {\n        return\n            _isDebtAmtDust(\n                _dsa,\n                _destVaultId,\n                _destColType,\n                _getMakerVaultDebt(_fromVaultId)\n            )\n                ? \"DebtAmtIsDust\"\n                : OK;\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/aave/ConditionMakerToAaveLiquid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {GelatoBytes} from \"../../../../lib/GelatoBytes.sol\";\nimport {\n    _isAaveLiquid\n} from \"../../../../functions/gelato/conditions/aave/FAaveHasLiquidity.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {_getMakerVaultDebt} from \"../../../../functions/dapps/FMaker.sol\";\n\ncontract ConditionMakerToAaveLiquid is GelatoConditionsStandard {\n    using GelatoBytes for bytes;\n\n    function getConditionData(uint256 _fromVaultId)\n        public\n        pure\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encodeWithSelector(this.hasLiquidity.selector, _fromVaultId);\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        uint256 _fromVaultId = abi.decode(_conditionData[4:], (uint256));\n\n        return hasLiquidity(_fromVaultId);\n    }\n\n    function hasLiquidity(uint256 _fromVaultId)\n        public\n        view\n        returns (string memory)\n    {\n        return\n            _isAaveLiquid(\n                DAI,\n                _getRealisedDebt(_getMakerVaultDebt(_fromVaultId))\n            )\n                ? OK\n                : \"AaveIlliquid\";\n    }\n}\n"
    },
    "contracts/contracts/resolvers/AaveResolver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {_getPosition, _percentDiv} from \"../../functions/dapps/FAave.sol\";\nimport {ILendingPool} from \"../../interfaces/dapps/Aave/ILendingPool.sol\";\nimport {AaveUserData, TokenPrice} from \"../../structs/SAave.sol\";\nimport {IERC20} from \"../../interfaces/dapps/IERC20.sol\";\nimport {\n    ILendingPoolAddressesProvider\n} from \"../../interfaces/dapps/Aave/ILendingPoolAddressesProvider.sol\";\nimport {ILendingPool} from \"../../interfaces/dapps/Aave/ILendingPool.sol\";\nimport {LENDING_POOL_ADDRESSES_PROVIDER} from \"../../constants/CAave.sol\";\nimport {\n    _isAaveLiquid\n} from \"../../functions/gelato/conditions/aave/FAaveHasLiquidity.sol\";\nimport {\n    _aavePositionWillBeSafe\n} from \"../../functions/gelato/conditions/aave/FAavePositionWillBeSafe.sol\";\n\ncontract AaveResolver {\n    function getPosition(address user)\n        public\n        view\n        returns (AaveUserData memory)\n    {\n        return _getPosition(user);\n    }\n\n    function percentDiv(uint256 value, uint256 percentage)\n        public\n        pure\n        returns (uint256)\n    {\n        return _percentDiv(value, percentage);\n    }\n\n    function getATokenUnderlyingBalance(address _underlying)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            IERC20(_underlying).balanceOf(\n                ILendingPool(\n                    ILendingPoolAddressesProvider(\n                        LENDING_POOL_ADDRESSES_PROVIDER\n                    )\n                        .getLendingPool()\n                )\n                    .getReserveData(_underlying)\n                    .aTokenAddress\n            );\n    }\n\n    function hasLiquidity(address _debtToken, uint256 _debtAmt)\n        public\n        view\n        returns (bool)\n    {\n        return _isAaveLiquid(_debtToken, _debtAmt);\n    }\n\n    function aavePositionWouldBeSafe(\n        address _dsa,\n        uint256 _colAmt,\n        address _debtToken,\n        uint256 _debtAmt,\n        address _priceOracle,\n        bytes memory _oraclePayload\n    ) public view returns (bool) {\n        return\n            _aavePositionWillBeSafe(\n                _dsa,\n                _colAmt,\n                _debtToken,\n                _debtAmt,\n                _priceOracle,\n                _oraclePayload\n            );\n    }\n}\n"
    },
    "contracts/contracts/gelato/conditions/aave/ConditionMakerToAaveSafe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    GelatoConditionsStandard\n} from \"@gelatonetwork/core/contracts/gelato_conditions/GelatoConditionsStandard.sol\";\nimport {DAI} from \"../../../../constants/CTokens.sol\";\nimport {\n    _aavePositionWillBeSafe\n} from \"../../../../functions/gelato/conditions/aave/FAavePositionWillBeSafe.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance\n} from \"../../../../functions/dapps/FMaker.sol\";\nimport {\n    _getRealisedDebt\n} from \"../../../../functions/gelato/FGelatoDebtBridge.sol\";\n\ncontract ConditionMakerToAaveSafe is GelatoConditionsStandard {\n    function getConditionData(\n        address _dsa,\n        uint256 _fromVaultId,\n        address _priceOracle,\n        bytes memory _oraclePayload\n    ) public pure virtual returns (bytes memory) {\n        return\n            abi.encodeWithSelector(\n                this.aavePositionWillBeSafe.selector,\n                _dsa,\n                _fromVaultId,\n                _priceOracle,\n                _oraclePayload\n            );\n    }\n\n    function ok(\n        uint256,\n        bytes calldata _conditionData,\n        uint256\n    ) public view virtual override returns (string memory) {\n        (\n            address _dsa,\n            uint256 _fromVaultId,\n            address _priceOracle,\n            bytes memory _oraclePayload\n        ) = abi.decode(_conditionData[4:], (address, uint256, address, bytes));\n\n        return\n            aavePositionWillBeSafe(\n                _dsa,\n                _fromVaultId,\n                _priceOracle,\n                _oraclePayload\n            );\n    }\n\n    function aavePositionWillBeSafe(\n        address _dsa,\n        uint256 _fromVaultId,\n        address _priceOracle,\n        bytes memory _oraclePayload\n    ) public view returns (string memory) {\n        return\n            _aavePositionWillBeSafe(\n                _dsa,\n                _getMakerVaultCollateralBalance(_fromVaultId),\n                DAI,\n                _getRealisedDebt(_getMakerVaultDebt(_fromVaultId)),\n                _priceOracle,\n                _oraclePayload\n            )\n                ? OK\n                : \"AavePositionWillNotBeSafe\";\n    }\n}\n"
    },
    "contracts/__mocks__/gelato/MockDebtBridgeExecutorETHB.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// import \"hardhat/console.sol\"; // Uncomment this line for using gasLeft Method\nimport {\n    TaskReceipt\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IGelatoCore\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IGelatoExecutors\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\";\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\n\n/// @dev Automatic gas-reporting for Debt Bridge use case\n//   via hardhat-gas-reporter\ncontract MockDebtBridgeExecutorETHB {\n    using GelatoBytes for bytes;\n    address public gelatoCore;\n\n    constructor(address _gelatoCore) payable {\n        gelatoCore = _gelatoCore;\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\n    }\n\n    function canExec(\n        TaskReceipt calldata _taskReceipt,\n        uint256 _gasLimit,\n        uint256 _execTxGasPrice\n    ) external view returns (string memory) {\n        return\n            IGelatoCore(gelatoCore).canExec(\n                _taskReceipt,\n                _gasLimit,\n                _execTxGasPrice\n            );\n    }\n\n    function exec(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost for Task Execution %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute0: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute0AndOpenVault(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\n        //     \"Gas Cost execViaRoute0AndOpenVault: %s\",\n        //     gasLeft - gasleft()\n        // );\n    }\n\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute1: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute1AndOpenVault(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\n        //     \"Gas Cost execViaRoute1AndOpenVault: %s\",\n        //     gasLeft - gasleft()\n        // );\n    }\n\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute2: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute2AndOpenVault(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\n        //     \"Gas Cost execViaRoute2AndOpenVault %s\",\n        //     gasLeft - gasleft()\n        // );\n    }\n\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute3: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute3AndOpenVault(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\n        //     \"Gas Cost execViaRoute3AndOpenVAult: %s\",\n        //     gasLeft - gasleft()\n        // );\n    }\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\n\ninterface IGelatoExecutors {\n    event LogExecutorStaked(address indexed executor, uint256 oldStake, uint256 newStake);\n    event LogExecutorUnstaked(address indexed executor);\n\n    event LogExecutorBalanceWithdrawn(\n        address indexed executor,\n        uint256 withdrawAmount\n    );\n\n    /// @notice Stake on Gelato to become a whitelisted executor\n    /// @dev Msg.value has to be >= minExecutorStake\n    function stakeExecutor() external payable;\n\n    /// @notice Unstake on Gelato to become de-whitelisted and withdraw minExecutorStake\n    function unstakeExecutor() external;\n\n    /// @notice Re-assigns multiple providers to other executors\n    /// @dev Executors must re-assign all providers before being able to unstake\n    /// @param _providers List of providers to re-assign\n    /// @param _newExecutor Address of new executor to assign providers to\n    function multiReassignProviders(address[] calldata _providers, address _newExecutor)\n        external;\n\n\n    /// @notice Withdraw excess Execur Stake\n    /// @dev Can only be called if executor is isExecutorMinStaked\n    /// @param _withdrawAmount Amount to withdraw\n    /// @return Amount that was actually withdrawn\n    function withdrawExcessExecutorStake(uint256 _withdrawAmount) external returns(uint256);\n\n}\n"
    },
    "contracts/__mocks__/gelato/MockDebtBridgeExecutorCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// import \"hardhat/console.sol\"; // Uncomment this line for using gasLeft Method\nimport {\n    TaskReceipt\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IGelatoCore\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IGelatoExecutors\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\";\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\n\n/// @dev Automatic gas-reporting for Debt Bridge use case\n//   via hardhat-gas-reporter\ncontract MockDebtBridgeExecutorCompound {\n    using GelatoBytes for bytes;\n    address public gelatoCore;\n\n    constructor(address _gelatoCore) payable {\n        gelatoCore = _gelatoCore;\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\n    }\n\n    function canExec(\n        TaskReceipt calldata _taskReceipt,\n        uint256 _gasLimit,\n        uint256 _execTxGasPrice\n    ) external view returns (string memory) {\n        return\n            IGelatoCore(gelatoCore).canExec(\n                _taskReceipt,\n                _gasLimit,\n                _execTxGasPrice\n            );\n    }\n\n    function stakeExecutor() external payable {\n        IGelatoExecutors(gelatoCore).stakeExecutor();\n    }\n\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute0: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute1: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute2: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute3: %s\", gasLeft - gasleft());\n    }\n}\n"
    },
    "contracts/__mocks__/gelato/MockDebtBridgeExecutorAave.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// import \"hardhat/console.sol\"; // Uncomment this line for using gasLeft Method\nimport {\n    TaskReceipt\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IGelatoCore\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {\n    IGelatoExecutors\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoExecutors.sol\";\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\n\n/// @dev Automatic gas-reporting for Debt Bridge use case\n//   via hardhat-gas-reporter\ncontract MockDebtBridgeExecutorAave {\n    using GelatoBytes for bytes;\n    address public gelatoCore;\n\n    constructor(address _gelatoCore) payable {\n        gelatoCore = _gelatoCore;\n        IGelatoExecutors(gelatoCore).stakeExecutor{value: msg.value}();\n    }\n\n    function canExec(\n        TaskReceipt calldata _taskReceipt,\n        uint256 _gasLimit,\n        uint256 _execTxGasPrice\n    ) external view returns (string memory) {\n        return\n            IGelatoCore(gelatoCore).canExec(\n                _taskReceipt,\n                _gasLimit,\n                _execTxGasPrice\n            );\n    }\n\n    function stakeExecutor() external payable {\n        IGelatoExecutors(gelatoCore).stakeExecutor();\n    }\n\n    function execViaRoute0(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute0: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute1(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute1: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute2(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute2: %s\", gasLeft - gasleft());\n    }\n\n    function execViaRoute3(TaskReceipt memory _taskReceipt) public {\n        // uint256 gasLeft = gasleft();\n        IGelatoCore(gelatoCore).exec(_taskReceipt);\n        // console.log(\"Gas Cost execViaRoute3: %s\", gasLeft - gasleft());\n    }\n}\n"
    },
    "contracts/__mocks__/connectors/MockConnectGelatoDataFullMakerToCompound.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GelatoBytes} from \"../../lib/GelatoBytes.sol\";\nimport {sub} from \"../../vendor/DSMath.sol\";\nimport {\n    AccountInterface,\n    ConnectorInterface\n} from \"../../interfaces/InstaDapp/IInstaDapp.sol\";\nimport {\n    IConnectInstaPoolV2\n} from \"../../interfaces/InstaDapp/connectors/IConnectInstaPoolV2.sol\";\nimport {\n    IBInstaFeeCollector\n} from \"../../interfaces/InstaDapp/connectors/base/IBInstaFeeCollector.sol\";\nimport {DAI} from \"../../constants/CTokens.sol\";\nimport {\n    CONNECT_MAKER,\n    CONNECT_COMPOUND,\n    CONNECT_BASIC,\n    INSTA_POOL_V2\n} from \"../../constants/CInstaDapp.sol\";\nimport {\n    _getMakerVaultDebt,\n    _getMakerVaultCollateralBalance,\n    _isVaultOwner\n} from \"../../functions/dapps/FMaker.sol\";\nimport {\n    _encodeFlashPayback\n} from \"../../functions/InstaDapp/connectors/FInstaPoolV2.sol\";\nimport {\n    _encodePaybackMakerVault,\n    _encodedWithdrawMakerVault\n} from \"../../functions/InstaDapp/connectors/FConnectMaker.sol\";\nimport {\n    _encodeDepositCompound,\n    _encodeBorrowCompound\n} from \"../../functions/InstaDapp/connectors/FConnectCompound.sol\";\nimport {\n    _encodeCalculateFee\n} from \"../../functions/InstaDapp/connectors/FConnectDebtBridgeFee.sol\";\nimport {_getGelatoExecutorFees} from \"../../functions/gelato/FGelato.sol\";\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToCompound,\n    _getRealisedDebt\n} from \"../../functions/gelato/FGelatoDebtBridge.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {IOracleAggregator} from \"../../interfaces/gelato/IOracleAggregator.sol\";\nimport {\n    BInstaFeeCollector\n} from \"../../contracts/connectors/base/BInstaFeeCollector.sol\";\nimport {\n    _encodeBasicWithdraw\n} from \"../../functions/InstaDapp/connectors/FConnectBasic.sol\";\n\ncontract MockConnectGelatoDataMakerToCompound is\n    ConnectorInterface,\n    BInstaFeeCollector\n{\n    using GelatoBytes for bytes;\n\n    string public constant OK = \"OK\";\n\n    // solhint-disable-next-line const-name-snakecase\n    string public constant override name =\n        \"ConnectGelatoDataMakerToCompound-v1.0\";\n    uint256 internal immutable _id;\n    address internal immutable _oracleAggregator;\n    address public immutable connectGelatoDataMakerToCompoundAddr;\n\n    constructor(\n        uint256 __id,\n        address __oracleAggregator,\n        uint256 _fee,\n        address payable _feeCollector,\n        uint256 _minDebt,\n        address __connectGelatoDebtBridgeFee\n    )\n        BInstaFeeCollector(\n            _fee,\n            _feeCollector,\n            _minDebt,\n            __connectGelatoDebtBridgeFee\n        )\n    {\n        _id = __id;\n        _oracleAggregator = __oracleAggregator;\n        connectGelatoDataMakerToCompoundAddr = address(this);\n    }\n\n    /// @dev Connector Details\n    function connectorID()\n        external\n        view\n        override\n        returns (uint256 _type, uint256 id)\n    {\n        (_type, id) = (1, _id); // Should put specific value.\n    }\n\n    // ====== ACTION TERMS CHECK ==========\n    /// @notice GelatoCore protocol standard function\n    /// @dev GelatoCore calls this to verify that a Task is executable\n    function termsOk(\n        uint256, // taskReceipId\n        address _dsa,\n        bytes calldata _actionData,\n        DataFlow, // DataFlow\n        uint256, // value\n        uint256 // cycleId\n    ) public view returns (string memory) {\n        (, uint256 vaultId, ) =\n            abi.decode(_actionData[4:], (uint256, uint256, address));\n\n        if (vaultId == 0)\n            return \"ConnectGelatoDataMakerToCompound: Vault Id is not valid\";\n        if (!_isVaultOwner(vaultId, _dsa))\n            return \"ConnectGelatoDataMakerToCompound: Vault not owned by dsa\";\n        if (_getMakerVaultCollateralBalance(vaultId) < minDebt)\n            return \"ConnectGelatoDataMakerToCompound: !minDebt\";\n        return OK;\n    }\n\n    /// @notice Entry Point for DSA.cast DebtBridge from Maker to Compound\n    /// @dev payable to be compatible in conjunction with DSA.cast payable target\n    /// @param _vaultId Id of the unsafe vault of the client.\n    /// @param _colToken  vault's col token address .\n    function getDataAndCastMakerToCompound(\n        uint256 _mockRoute,\n        uint256 _vaultId,\n        address _colToken\n    ) external payable {\n        (address[] memory targets, bytes[] memory datas) =\n            _dataMakerToCompound(_mockRoute, _vaultId, _colToken);\n\n        _cast(targets, datas);\n    }\n\n    function _cast(address[] memory targets, bytes[] memory datas) internal {\n        // Instapool V2 / FlashLoan call\n        bytes memory castData =\n            abi.encodeWithSelector(\n                AccountInterface.cast.selector,\n                targets,\n                datas,\n                msg.sender // msg.sender == GelatoCore\n            );\n\n        (bool success, bytes memory returndata) =\n            address(this).delegatecall(castData);\n        if (!success) {\n            returndata.revertWithError(\n                \"ConnectGelatoDataMakerToCompound._cast:\"\n            );\n        }\n    }\n\n    /* solhint-disable function-max-lines */\n\n    function _dataMakerToCompound(\n        uint256 _mockRoute,\n        uint256 _vaultId,\n        address _colToken\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](1);\n        targets[0] = INSTA_POOL_V2;\n\n        uint256 daiToBorrow = _getRealisedDebt(_getMakerVaultDebt(_vaultId));\n\n        uint256 route = _getFlashLoanRoute(DAI, daiToBorrow);\n        route = _mockRoute;\n        (uint256 gasFeesPaidFromBor, ) =\n            IOracleAggregator(_oracleAggregator).getExpectedReturnAmount(\n                _getGelatoExecutorFees(_getGasCostMakerToCompound(route)),\n                _colToken,\n                DAI\n            );\n        (address[] memory _targets, bytes[] memory _datas) =\n            _spellsMakerToCompound(\n                _vaultId,\n                _colToken,\n                daiToBorrow,\n                _getMakerVaultCollateralBalance(_vaultId),\n                gasFeesPaidFromBor\n            );\n\n        datas = new bytes[](1);\n        datas[0] = abi.encodeWithSelector(\n            IConnectInstaPoolV2.flashBorrowAndCast.selector,\n            DAI,\n            daiToBorrow,\n            route,\n            abi.encode(_targets, _datas)\n        );\n    }\n\n    function _spellsMakerToCompound(\n        uint256 _vaultId,\n        address _colToken,\n        uint256 _daiDebtAmt,\n        uint256 _colToWithdrawFromMaker,\n        uint256 _gasFeesPaidFromDebt\n    ) internal view returns (address[] memory targets, bytes[] memory datas) {\n        targets = new address[](8);\n        targets[0] = CONNECT_MAKER; // payback\n        targets[1] = CONNECT_MAKER; // withdraw\n        targets[2] = _connectGelatoDebtBridgeFee; // calculate fee\n        targets[3] = CONNECT_COMPOUND; // deposit\n        targets[4] = CONNECT_COMPOUND; // borrow\n        targets[5] = CONNECT_BASIC; // pay fee to instadapp fee collector\n        targets[6] = CONNECT_BASIC; // pay fast transaction fee to gelato executor\n        targets[7] = INSTA_POOL_V2; // flashPayback\n\n        datas = new bytes[](8);\n        datas[0] = _encodePaybackMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            600\n        );\n        datas[1] = _encodedWithdrawMakerVault(\n            _vaultId,\n            type(uint256).max,\n            0,\n            0\n        );\n        datas[2] = _encodeCalculateFee(\n            0,\n            _gasFeesPaidFromDebt,\n            IBInstaFeeCollector(connectGelatoDataMakerToCompoundAddr).fee(),\n            600,\n            600,\n            601\n        );\n        datas[3] = _encodeDepositCompound(\n            _colToken,\n            _colToWithdrawFromMaker,\n            0,\n            0\n        );\n        datas[4] = _encodeBorrowCompound(DAI, 0, 600, 0);\n        datas[5] = _encodeBasicWithdraw(\n            DAI,\n            0,\n            IBInstaFeeCollector(connectGelatoDataMakerToCompoundAddr)\n                .feeCollector(),\n            601,\n            0\n        );\n        datas[6] = _encodeBasicWithdraw(\n            DAI,\n            _gasFeesPaidFromDebt,\n            payable(tx.origin),\n            0,\n            0\n        );\n        datas[7] = _encodeFlashPayback(DAI, _daiDebtAmt, 0, 0);\n    }\n\n    /* solhint-enable function-max-lines */\n}\n"
    },
    "contracts/__mocks__/gelato/MockFGelatoDebtBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    _getFlashLoanRoute,\n    _getGasCostMakerToMaker,\n    _getGasCostMakerToCompound,\n    _getRealisedDebt\n} from \"../../functions/gelato/FGelatoDebtBridge.sol\";\n\ncontract FGelatoDebtBridgeMock {\n    function getFlashLoanRoute(address _tokenA, uint256 _tokenADebtToMove)\n        public\n        view\n        returns (uint256)\n    {\n        return _getFlashLoanRoute(_tokenA, _tokenADebtToMove);\n    }\n\n    function getGasCostMakerToMaker(bool _newVault, uint256 _route)\n        public\n        pure\n        returns (uint256)\n    {\n        return _getGasCostMakerToMaker(_newVault, _route);\n    }\n\n    function getGasCostMakerToCompound(uint256 _route)\n        public\n        pure\n        returns (uint256)\n    {\n        return _getGasCostMakerToCompound(_route);\n    }\n\n    function getRealisedDebt(uint256 _debtToMove)\n        public\n        pure\n        returns (uint256)\n    {\n        return _getRealisedDebt(_debtToMove);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
